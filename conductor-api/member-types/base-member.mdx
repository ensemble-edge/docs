---
title: "Base Member"
description: "Base class for all member types"
---

## Overview

The `BaseMember` class is the abstract base class that all member types extend. It provides common functionality for execution, validation, caching, retry logic, and lifecycle hooks.

```typescript
import { BaseMember } from '@ensemble-edge/conductor';

class CustomMember extends BaseMember {
  async execute(input: any): Promise<any> {
    // Implementation
  }
}
```

## Abstract Class

```typescript
abstract class BaseMember {
  abstract execute(input: any): Promise<any>;
}
```

All custom members must extend `BaseMember` and implement the `execute()` method.

## Constructor

```typescript
constructor(options: MemberOptions)
```

<ParamField body="options" type="MemberOptions" required>
  Member configuration options

  <ParamField body="options.name" type="string" required>
    Unique member name
  </ParamField>

  <ParamField body="options.type" type="string" required>
    Member type: `Think`, `Function`, `Data`, `API`
  </ParamField>

  <ParamField body="options.config" type="object">
    Type-specific configuration
  </ParamField>

  <ParamField body="options.cache" type="CacheConfig">
    Caching configuration
  </ParamField>

  <ParamField body="options.retry" type="RetryConfig">
    Retry configuration
  </ParamField>

  <ParamField body="options.timeout" type="number" default="30000">
    Execution timeout in milliseconds
  </ParamField>

  <ParamField body="options.metadata" type="object">
    Additional metadata
  </ParamField>
</ParamField>

```typescript
interface MemberOptions {
  name: string;
  type: string;
  config?: Record<string, any>;
  cache?: CacheConfig;
  retry?: RetryConfig;
  timeout?: number;
  metadata?: Record<string, any>;
}
```

## Abstract Methods

### execute()

Execute the member logic (must be implemented).

```typescript
abstract execute(input: any): Promise<any>
```

<ParamField body="input" type="any" required>
  Input data for execution
</ParamField>

**Returns**: `Promise<any>` - Execution result

**Example Implementation**:

```typescript
class ValidateEmailMember extends BaseMember {
  async execute(input: { email: string }): Promise<{ valid: boolean }> {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return {
      valid: emailRegex.test(input.email)
    };
  }
}
```

## Lifecycle Hooks

### beforeExecute()

Called before execute(), useful for validation and setup.

```typescript
async beforeExecute(input: any): Promise<void>
```

**Example**:

```typescript
class CustomMember extends BaseMember {
  async beforeExecute(input: any): Promise<void> {
    // Validate input
    if (!input.userId) {
      throw new Error('userId is required');
    }

    // Log execution start
    console.log(`Executing ${this.name} for user ${input.userId}`);

    // Setup resources
    await this.initializeResources();
  }

  async execute(input: any): Promise<any> {
    // Main logic
  }
}
```

### afterExecute()

Called after execute(), useful for cleanup and post-processing.

```typescript
async afterExecute(output: any): Promise<any>
```

<ParamField body="output" type="any" required>
  Output from execute()
</ParamField>

**Returns**: `Promise<any>` - Transformed output

**Example**:

```typescript
class CustomMember extends BaseMember {
  async execute(input: any): Promise<any> {
    return { result: 'success', data: input };
  }

  async afterExecute(output: any): Promise<any> {
    // Transform output
    output.timestamp = Date.now();
    output.member = this.name;

    // Log result
    console.log(`${this.name} completed:`, output);

    // Cleanup
    await this.cleanup();

    return output;
  }
}
```

### onError()

Called when execute() throws an error.

```typescript
async onError(error: Error, input: any): Promise<void>
```

<ParamField body="error" type="Error" required>
  Error that occurred
</ParamField>

<ParamField body="input" type="any" required>
  Input that caused error
</ParamField>

**Example**:

```typescript
class CustomMember extends BaseMember {
  async onError(error: Error, input: any): Promise<void> {
    // Log error with context
    console.error(`Error in ${this.name}:`, {
      error: error.message,
      input,
      timestamp: Date.now()
    });

    // Send alert
    await this.sendErrorAlert(error, input);

    // Cleanup resources
    await this.cleanup();

    // Re-throw or transform error
    throw new MemberError(
      `${this.name} failed: ${error.message}`,
      { cause: error, input }
    );
  }

  async execute(input: any): Promise<any> {
    // Implementation
  }
}
```

## Properties

### name

```typescript
readonly name: string
```

Unique member name.

### type

```typescript
readonly type: string
```

Member type: `Think`, `Function`, `Data`, `API`.

### config

```typescript
readonly config: Record<string, any>
```

Type-specific configuration.

### timeout

```typescript
readonly timeout: number
```

Execution timeout in milliseconds.

### metadata

```typescript
readonly metadata: Record<string, any>
```

Additional metadata.

## Caching

### Cache Configuration

```typescript
interface CacheConfig {
  enabled: boolean;
  ttl: number;
  key?: string | ((input: any) => string);
  namespace?: string;
  invalidateOn?: string[];
}
```

**Example**:

```yaml
- member: fetch-user
  type: Function
  cache:
    enabled: true
    ttl: 300000  # 5 minutes
    key: ${input.userId}
    namespace: users
```

### getCacheKey()

Generate cache key for input.

```typescript
getCacheKey(input: any): string
```

**Override for custom keys**:

```typescript
class CustomMember extends BaseMember {
  getCacheKey(input: any): string {
    // Custom cache key logic
    return `${this.name}:${input.userId}:${input.date}`;
  }

  async execute(input: any): Promise<any> {
    // Implementation
  }
}
```

### shouldCache()

Determine if result should be cached.

```typescript
shouldCache(input: any, output: any): boolean
```

**Override for conditional caching**:

```typescript
class CustomMember extends BaseMember {
  shouldCache(input: any, output: any): boolean {
    // Only cache successful results
    return output.status === 'success';
  }

  async execute(input: any): Promise<any> {
    // Implementation
  }
}
```

## Retry Logic

### Retry Configuration

```typescript
interface RetryConfig {
  maxAttempts: number;
  backoff: 'fixed' | 'exponential' | 'linear';
  initialDelay?: number;
  maxDelay?: number;
  retryIf?: (error: Error) => boolean;
}
```

**Example**:

```yaml
- member: api-call
  type: API
  retry:
    maxAttempts: 3
    backoff: exponential
    initialDelay: 1000
    maxDelay: 10000
```

### shouldRetry()

Determine if execution should be retried.

```typescript
shouldRetry(error: Error, attempt: number): boolean
```

**Override for custom retry logic**:

```typescript
class CustomMember extends BaseMember {
  shouldRetry(error: Error, attempt: number): boolean {
    // Retry on network errors
    if (error.name === 'NetworkError') {
      return attempt < 3;
    }

    // Don't retry validation errors
    if (error instanceof ValidationError) {
      return false;
    }

    // Default retry logic
    return super.shouldRetry(error, attempt);
  }

  async execute(input: any): Promise<any> {
    // Implementation
  }
}
```

## Validation

### validateInput()

Validate input before execution.

```typescript
validateInput(input: any): void
```

**Example**:

```typescript
class CustomMember extends BaseMember {
  validateInput(input: any): void {
    if (!input.email) {
      throw new ValidationError('email is required');
    }

    if (!input.email.includes('@')) {
      throw new ValidationError('invalid email format');
    }
  }

  async execute(input: any): Promise<any> {
    this.validateInput(input);
    // Implementation
  }
}
```

### validateOutput()

Validate output after execution.

```typescript
validateOutput(output: any): void
```

**Example**:

```typescript
class CustomMember extends BaseMember {
  async execute(input: any): Promise<any> {
    const output = { /* ... */ };
    this.validateOutput(output);
    return output;
  }

  validateOutput(output: any): void {
    if (!output.userId) {
      throw new ValidationError('userId missing in output');
    }

    if (typeof output.userId !== 'string') {
      throw new ValidationError('userId must be a string');
    }
  }
}
```

## Context Access

### getContext()

Access execution context.

```typescript
getContext(): ExecutionContext
```

```typescript
interface ExecutionContext {
  executionId: string;
  parentExecutionId?: string;
  input: Record<string, any>;
  memberOutputs: Map<string, any>;
  env: Env;
  metadata: Record<string, any>;
}
```

**Example**:

```typescript
class CustomMember extends BaseMember {
  async execute(input: any): Promise<any> {
    const context = this.getContext();

    console.log('Execution ID:', context.executionId);
    console.log('Original input:', context.input);

    // Access previous member outputs
    const previousResult = context.memberOutputs.get('previous-member');

    // Access environment
    const apiKey = context.env.API_KEY;

    return { /* ... */ };
  }
}
```

## Creating Custom Members

### Basic Custom Member

```typescript
import { BaseMember } from '@ensemble-edge/conductor';

class TransformDataMember extends BaseMember {
  async execute(input: { data: any[] }): Promise<{ transformed: any[] }> {
    const transformed = input.data.map(item => ({
      ...item,
      processed: true,
      timestamp: Date.now()
    }));

    return { transformed };
  }
}
```

### With Lifecycle Hooks

```typescript
class EnhancedMember extends BaseMember {
  async beforeExecute(input: any): Promise<void> {
    console.log(`Starting ${this.name}`);
    this.validateInput(input);
  }

  async execute(input: any): Promise<any> {
    // Main logic
    return { result: 'success' };
  }

  async afterExecute(output: any): Promise<any> {
    output.executedAt = Date.now();
    output.member = this.name;
    return output;
  }

  async onError(error: Error, input: any): Promise<void> {
    console.error(`Error in ${this.name}:`, error);
    // Send notification
    await this.notifyError(error, input);
  }

  validateInput(input: any): void {
    if (!input.required) {
      throw new Error('Missing required field');
    }
  }
}
```

### With Caching

```typescript
class CachedAPIMember extends BaseMember {
  getCacheKey(input: any): string {
    return `api:${input.endpoint}:${JSON.stringify(input.params)}`;
  }

  shouldCache(input: any, output: any): boolean {
    return output.status === 200;
  }

  async execute(input: { endpoint: string; params: object }): Promise<any> {
    const response = await fetch(input.endpoint, {
      method: 'POST',
      body: JSON.stringify(input.params)
    });

    return {
      status: response.status,
      data: await response.json()
    };
  }
}
```

## Testing

```typescript
import { BaseMember } from '@ensemble-edge/conductor';
import { describe, it, expect, beforeEach } from 'vitest';

class TestMember extends BaseMember {
  async execute(input: { value: number }): Promise<{ doubled: number }> {
    return { doubled: input.value * 2 };
  }
}

describe('TestMember', () => {
  let member: TestMember;

  beforeEach(() => {
    member = new TestMember({
      name: 'test-member',
      type: 'Function'
    });
  });

  it('executes successfully', async () => {
    const result = await member.execute({ value: 5 });
    expect(result.doubled).toBe(10);
  });

  it('handles errors', async () => {
    const errorMember = new TestMember({
      name: 'error-member',
      type: 'Function'
    });

    errorMember.execute = async () => {
      throw new Error('Test error');
    };

    await expect(errorMember.execute({})).rejects.toThrow('Test error');
  });

  it('calls lifecycle hooks', async () => {
    const calls: string[] = [];

    member.beforeExecute = async () => {
      calls.push('before');
    };

    member.afterExecute = async (output) => {
      calls.push('after');
      return output;
    };

    await member.execute({ value: 5 });

    expect(calls).toEqual(['before', 'after']);
  });
});
```

## Best Practices

1. **Implement all lifecycle hooks** - For robust error handling
2. **Validate input** - Fail fast on bad data
3. **Use descriptive names** - Clear member identification
4. **Handle errors gracefully** - Provide context
5. **Cache when appropriate** - Improve performance
6. **Set reasonable timeouts** - Prevent hanging
7. **Log important events** - Aid debugging
8. **Test thoroughly** - All code paths
9. **Document behavior** - Clear expectations
10. **Keep execute() focused** - Single responsibility

## Related Documentation

<CardGroup cols={2}>
  <Card
    title="Think Member"
    icon="brain"
    href="/conductor-api/member-types/think-member"
  >
    AI-powered reasoning member
  </Card>

  <Card
    title="Function Member"
    icon="function"
    href="/conductor-api/member-types/function-member"
  >
    Custom logic member
  </Card>

  <Card
    title="Data Member"
    icon="database"
    href="/conductor-api/member-types/data-member"
  >
    Data operations member
  </Card>

  <Card
    title="API Member"
    icon="globe"
    href="/conductor-api/member-types/api-member"
  >
    HTTP API call member
  </Card>
</CardGroup>
