---
title: "TestConductor"
description: "Testing helper for executing and testing Conductor ensembles"
---

## Overview

`TestConductor` is a powerful testing utility that provides a complete test environment for Conductor workflows. It includes mocking capabilities, execution tracking, and comprehensive assertions.

```typescript
import { TestConductor } from '@ensemble-edge/conductor/testing';

const conductor = await TestConductor.create({
  projectPath: './conductor'
});

const result = await conductor.executeEnsemble('user-onboarding', {
  email: 'test@example.com'
});

expect(result.success).toBe(true);
expect(result.output).toMatchObject({ userId: expect.any(String) });
```

## Installation

```bash
npm install --save-dev @ensemble-edge/conductor
```

## Constructor

### create()

Create a new TestConductor instance:

```typescript
static async create(options?: TestConductorOptions): Promise<TestConductor>
```

<ParamField body="options" type="TestConductorOptions">
  Test conductor configuration

  <ParamField body="options.projectPath" type="string">
    Path to Conductor project directory
  </ParamField>

  <ParamField body="options.env" type="object">
    Mock environment variables and bindings
  </ParamField>

  <ParamField body="options.mocks" type="object">
    Mock configuration for AI, database, HTTP, Vectorize
  </ParamField>
</ParamField>

**Example**:

```typescript
const conductor = await TestConductor.create({
  projectPath: './conductor',
  env: {
    OPENAI_API_KEY: 'test-key',
    DATABASE_URL: 'mock-db'
  },
  mocks: {
    ai: {
      'generate-greeting': { message: 'Hello, Test!' }
    },
    database: {
      users: [
        { id: 1, email: 'test@example.com' }
      ]
    }
  }
});
```

## Execution Methods

### executeEnsemble()

Execute an ensemble in test mode:

```typescript
async executeEnsemble(
  name: string,
  input: Record<string, unknown>
): Promise<TestExecutionResult>
```

<ParamField path="name" type="string" required>
  Name of the ensemble to execute
</ParamField>

<ParamField path="input" type="object" required>
  Input data for the ensemble
</ParamField>

**Returns**: `Promise<TestExecutionResult>`

```typescript
interface TestExecutionResult {
  success: boolean;
  output?: unknown;
  error?: Error;
  executionTime: number;
  stepsExecuted: ExecutedStep[];
  stateHistory: StateSnapshot[];
  aiCalls: AICall[];
  databaseQueries: DatabaseQuery[];
  httpRequests: HTTPRequest[];
}
```

**Example**:

```typescript
const result = await conductor.executeEnsemble('order-processing', {
  orderId: 'ORD-123',
  customerId: 'CUST-456'
});

console.log(result.success); // true
console.log(result.output); // { status: 'processed', total: 99.99 }
console.log(result.executionTime); // 234 (ms)
console.log(result.stepsExecuted.length); // 5
```

### executeMember()

Execute a single member directly:

```typescript
async executeMember(
  name: string,
  input: unknown
): Promise<TestMemberResult>
```

<ParamField path="name" type="string" required>
  Name of the member to execute
</ParamField>

<ParamField path="input" type="unknown" required>
  Input data for the member
</ParamField>

**Example**:

```typescript
const result = await conductor.executeMember('validate-email', {
  email: 'test@example.com'
});

expect(result.output.valid).toBe(true);
```

## Mocking Methods

### mockAI()

Mock AI provider responses:

```typescript
mockAI(memberName: string, response: unknown | Error): void
```

<ParamField path="memberName" type="string" required>
  Name of the AI member to mock
</ParamField>

<ParamField path="response" type="unknown | Error" required>
  Mock response or error to return
</ParamField>

**Example**:

```typescript
// Mock successful AI response
conductor.mockAI('generate-summary', {
  summary: 'This is a test summary'
});

// Mock AI error
conductor.mockAI('generate-summary', new Error('AI service unavailable'));
```

### mockDatabase()

Mock database data:

```typescript
mockDatabase(table: string, data: unknown[]): void
```

<ParamField path="table" type="string" required>
  Database table name
</ParamField>

<ParamField path="data" type="array" required>
  Array of records to populate the table
</ParamField>

**Example**:

```typescript
conductor.mockDatabase('users', [
  { id: 1, email: 'alice@example.com', name: 'Alice' },
  { id: 2, email: 'bob@example.com', name: 'Bob' }
]);

conductor.mockDatabase('orders', [
  { id: 'ORD-1', userId: 1, total: 99.99, status: 'pending' }
]);
```

### mockAPI()

Mock external API responses:

```typescript
mockAPI(url: string, response: unknown): void
```

<ParamField path="url" type="string" required>
  API URL to mock
</ParamField>

<ParamField path="response" type="unknown" required>
  Mock response data
</ParamField>

**Example**:

```typescript
conductor.mockAPI('https://api.stripe.com/v1/charges', {
  id: 'ch_123',
  status: 'succeeded',
  amount: 9999
});

conductor.mockAPI('https://api.weather.com/forecast', {
  temperature: 72,
  condition: 'sunny'
});
```

## Catalog Methods

### addEnsemble()

Add an ensemble to the test catalog:

```typescript
addEnsemble(name: string, config: EnsembleConfig): void
```

**Example**:

```typescript
conductor.addEnsemble('test-ensemble', {
  name: 'test-ensemble',
  description: 'Test ensemble',
  flow: [
    {
      member: 'greet',
      type: 'Think',
      config: {
        provider: 'cloudflare',
        model: '@cf/meta/llama-3.1-8b-instruct'
      },
      input: {
        prompt: 'Say hello to ${input.name}'
      }
    }
  ],
  output: {
    greeting: '${greet.output.text}'
  }
});
```

### addMember()

Add a member to the test catalog:

```typescript
addMember(name: string, config: MemberConfig): void
```

**Example**:

```typescript
conductor.addMember('validate-email', {
  name: 'validate-email',
  type: 'Function',
  config: {
    handler: (input) => ({
      valid: /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(input.email)
    })
  }
});
```

### getEnsemble()

Get an ensemble from the catalog:

```typescript
getEnsemble(name: string): EnsembleConfig | undefined
```

### getMember()

Get a member from the catalog:

```typescript
getMember(name: string): MemberConfig | undefined
```

## History Methods

### getExecutionHistory()

Get all execution records:

```typescript
getExecutionHistory(): ExecutionRecord[]
```

**Example**:

```typescript
const history = conductor.getExecutionHistory();

console.log(`Total executions: ${history.length}`);
console.log(`Success rate: ${history.filter(e => e.success).length / history.length * 100}%`);
```

### getAICalls()

Get all AI calls from execution history:

```typescript
getAICalls(): AICall[]
```

**Example**:

```typescript
const aiCalls = conductor.getAICalls();

const totalTokens = aiCalls.reduce(
  (sum, call) => sum + (call.usage?.totalTokens || 0),
  0
);
console.log(`Total tokens used: ${totalTokens}`);
```

### getDatabaseQueries()

Get all database queries from execution history:

```typescript
getDatabaseQueries(): DatabaseQuery[]
```

**Example**:

```typescript
const queries = conductor.getDatabaseQueries();

console.log(`Total queries: ${queries.length}`);
console.log(`Slowest query: ${Math.max(...queries.map(q => q.duration))}ms`);
```

## Utility Methods

### snapshot()

Create a snapshot of the current project state:

```typescript
async snapshot(): Promise<ProjectSnapshot>
```

**Example**:

```typescript
const snapshot = await conductor.snapshot();

console.log(`Ensembles: ${snapshot.catalog.ensembles.size}`);
console.log(`Members: ${snapshot.catalog.members.size}`);
```

### cleanup()

Cleanup test resources:

```typescript
async cleanup(): Promise<void>
```

**Example**:

```typescript
afterEach(async () => {
  await conductor.cleanup();
});
```

## Testing Patterns

### Basic Test

```typescript
import { TestConductor } from '@ensemble-edge/conductor/testing';
import { describe, it, expect, beforeAll, afterEach } from 'vitest';

describe('User Onboarding', () => {
  let conductor: TestConductor;

  beforeAll(async () => {
    conductor = await TestConductor.create({
      projectPath: './conductor'
    });
  });

  afterEach(async () => {
    await conductor.cleanup();
  });

  it('creates new user', async () => {
    const result = await conductor.executeEnsemble('user-onboarding', {
      email: 'newuser@example.com',
      name: 'New User'
    });

    expect(result.success).toBe(true);
    expect(result.output).toMatchObject({
      userId: expect.any(String),
      email: 'newuser@example.com'
    });
  });
});
```

### With Mocks

```typescript
it('handles AI failures gracefully', async () => {
  conductor.mockAI('generate-welcome', new Error('AI service down'));

  const result = await conductor.executeEnsemble('user-onboarding', {
    email: 'test@example.com'
  });

  expect(result.success).toBe(false);
  expect(result.error?.message).toContain('AI service down');
});
```

### Testing Performance

```typescript
it('completes within 500ms', async () => {
  const result = await conductor.executeEnsemble('quick-check', {
    data: 'test'
  });

  expect(result.success).toBe(true);
  expect(result.executionTime).toBeLessThan(500);
});
```

### Testing AI Costs

```typescript
it('uses less than 1000 tokens', async () => {
  await conductor.executeEnsemble('content-generation', {
    topic: 'testing'
  });

  const aiCalls = conductor.getAICalls();
  const totalTokens = aiCalls.reduce(
    (sum, call) => sum + (call.usage?.totalTokens || 0),
    0
  );

  expect(totalTokens).toBeLessThan(1000);
});
```

### Testing Data Operations

```typescript
it('creates database records', async () => {
  conductor.mockDatabase('users', []);

  await conductor.executeEnsemble('create-user', {
    email: 'test@example.com'
  });

  const queries = conductor.getDatabaseQueries();
  const insertQueries = queries.filter(q => q.operation === 'INSERT');

  expect(insertQueries).toHaveLength(1);
  expect(insertQueries[0].table).toBe('users');
});
```

### Testing External APIs

```typescript
it('calls payment API', async () => {
  conductor.mockAPI('https://api.stripe.com/v1/charges', {
    id: 'ch_test',
    status: 'succeeded'
  });

  const result = await conductor.executeEnsemble('process-payment', {
    amount: 9999,
    currency: 'usd'
  });

  expect(result.success).toBe(true);
  expect(result.httpRequests).toHaveLength(1);
  expect(result.httpRequests[0].url).toContain('stripe.com');
});
```

## Best Practices

1. **Use projectPath** - Load ensembles and members automatically
2. **Mock external services** - Avoid real API calls in tests
3. **Clean up after tests** - Use `cleanup()` in `afterEach`
4. **Test error paths** - Mock failures to test error handling
5. **Check execution time** - Ensure workflows are performant
6. **Monitor AI usage** - Track tokens and costs
7. **Verify state** - Check state history for correctness
8. **Test with real data** - Use realistic test data
9. **Isolate tests** - Each test should be independent
10. **Use snapshots** - Compare outputs with snapshots

## Related Documentation

<CardGroup cols={2}>
  <Card
    title="Custom Matchers"
    icon="check"
    href="/conductor-api/testing/matchers"
  >
    Vitest matchers for assertions
  </Card>

  <Card
    title="Mocks"
    icon="mask"
    href="/conductor-api/testing/mocks"
  >
    Mock utilities and helpers
  </Card>

  <Card
    title="Testing Guide"
    icon="flask"
    href="/conductor/guides/testing"
  >
    Testing workflows guide
  </Card>

  <Card
    title="CI/CD"
    icon="circle-check"
    href="/conductor/guides/ci-cd"
  >
    Continuous integration setup
  </Card>
</CardGroup>
