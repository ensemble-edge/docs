---
title: "Health Check API"
description: "Monitor system health and readiness"
api: "GET https://your-worker.workers.dev/health"
---

## Health Check

<api>GET /health</api>

Comprehensive health check of all system components.

### Response

<ResponseField name="status" type="string">
  Overall health status: `healthy`, `degraded`, `unhealthy`
</ResponseField>

<ResponseField name="timestamp" type="number">
  Health check timestamp
</ResponseField>

<ResponseField name="version" type="string">
  Conductor version
</ResponseField>

<ResponseField name="components" type="object">
  Component-specific health

  <ResponseField name="components.database" type="string">
    D1 database status: `ok`, `error`
  </ResponseField>

  <ResponseField name="components.kv" type="string">
    KV namespace status
  </ResponseField>

  <ResponseField name="components.ai" type="string">
    AI provider status
  </ResponseField>

  <ResponseField name="components.vectorize" type="string">
    Vectorize index status
  </ResponseField>
</ResponseField>

<ResponseField name="uptime" type="number">
  Worker uptime in milliseconds
</ResponseField>

<RequestExample>

```bash cURL
curl https://your-worker.workers.dev/health
```

```javascript JavaScript
const response = await fetch('https://your-worker.workers.dev/health');
const health = await response.json();

if (health.status === 'healthy') {
  console.log('System is healthy');
} else {
  console.error('System has issues:', health.components);
}
```

```python Python
import requests

response = requests.get('https://your-worker.workers.dev/health')
health = response.json()

print(f"Status: {health['status']}")
```

</RequestExample>

<ResponseExample>

```json Healthy (200)
{
  "status": "healthy",
  "timestamp": 1704067200000,
  "version": "1.0.0",
  "components": {
    "database": "ok",
    "kv": "ok",
    "ai": "ok",
    "vectorize": "ok"
  },
  "uptime": 3600000
}
```

```json Degraded (200)
{
  "status": "degraded",
  "timestamp": 1704067200000,
  "version": "1.0.0",
  "components": {
    "database": "ok",
    "kv": "ok",
    "ai": "error",
    "vectorize": "ok"
  },
  "errors": [
    {
      "component": "ai",
      "message": "AI provider timeout"
    }
  ],
  "uptime": 3600000
}
```

```json Unhealthy (503)
{
  "status": "unhealthy",
  "timestamp": 1704067200000,
  "version": "1.0.0",
  "components": {
    "database": "error",
    "kv": "error",
    "ai": "ok",
    "vectorize": "ok"
  },
  "errors": [
    {
      "component": "database",
      "message": "Connection failed"
    },
    {
      "component": "kv",
      "message": "Namespace not found"
    }
  ],
  "uptime": 3600000
}
```

</ResponseExample>

---

## Readiness Probe

<api>GET /health/ready</api>

Check if worker is ready to accept traffic (Kubernetes-style readiness probe).

### Response

<ResponseField name="ready" type="boolean">
  Whether worker is ready
</ResponseField>

<ResponseField name="timestamp" type="number">
  Check timestamp
</ResponseField>

<RequestExample>

```bash cURL
curl https://your-worker.workers.dev/health/ready
```

```yaml Kubernetes
livenessProbe:
  httpGet:
    path: /health/ready
    port: 80
  initialDelaySeconds: 3
  periodSeconds: 10
```

</RequestExample>

<ResponseExample>

```json Ready (200)
{
  "ready": true,
  "timestamp": 1704067200000
}
```

```json Not Ready (503)
{
  "ready": false,
  "reason": "Database connection not established",
  "timestamp": 1704067200000
}
```

</ResponseExample>

---

## Liveness Probe

<api>GET /health/alive</api>

Check if worker is alive (Kubernetes-style liveness probe).

### Response

<ResponseField name="alive" type="boolean">
  Whether worker is alive
</ResponseField>

<ResponseField name="timestamp" type="number">
  Check timestamp
</ResponseField>

<RequestExample>

```bash cURL
curl https://your-worker.workers.dev/health/alive
```

```yaml Kubernetes
livenessProbe:
  httpGet:
    path: /health/alive
    port: 80
  initialDelaySeconds: 5
  periodSeconds: 30
```

</RequestExample>

<ResponseExample>

```json Alive (200)
{
  "alive": true,
  "timestamp": 1704067200000
}
```

</ResponseExample>

---

## Implementation

### Basic Health Check

```typescript
// src/index.ts
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    if (url.pathname === '/health') {
      const health = {
        status: 'healthy',
        timestamp: Date.now(),
        version: env.VERSION || '1.0.0',
        components: {}
      };

      // Check database
      try {
        await env.DB.prepare('SELECT 1').run();
        health.components.database = 'ok';
      } catch (error) {
        health.components.database = 'error';
        health.status = 'unhealthy';
      }

      // Check KV
      try {
        await env.CACHE.get('health-check');
        health.components.kv = 'ok';
      } catch (error) {
        health.components.kv = 'error';
        health.status = 'unhealthy';
      }

      const status = health.status === 'healthy' ? 200 : 503;
      return Response.json(health, { status });
    }

    // ... rest of worker
  }
};
```

### Comprehensive Health Check

```typescript
async function healthCheck(env: Env): Promise<HealthStatus> {
  const health: HealthStatus = {
    status: 'healthy',
    timestamp: Date.now(),
    version: '1.0.0',
    components: {},
    errors: []
  };

  // Check D1 Database
  await checkComponent(health, 'database', async () => {
    await env.DB.prepare('SELECT 1').run();
  });

  // Check KV Namespace
  await checkComponent(health, 'kv', async () => {
    await env.CACHE.get('health-check');
  });

  // Check AI Provider
  await checkComponent(health, 'ai', async () => {
    await env.AI.run('@cf/meta/llama-3.1-8b-instruct', {
      prompt: 'test'
    });
  });

  // Check Vectorize
  await checkComponent(health, 'vectorize', async () => {
    await env.VECTORIZE.query([0.1, 0.2, 0.3], { topK: 1 });
  });

  return health;
}

async function checkComponent(
  health: HealthStatus,
  name: string,
  check: () => Promise<void>
): Promise<void> {
  try {
    await check();
    health.components[name] = 'ok';
  } catch (error) {
    health.components[name] = 'error';
    health.status = 'degraded';
    health.errors?.push({
      component: name,
      message: error.message
    });
  }
}
```

### Readiness Check

```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    if (request.url.endsWith('/health/ready')) {
      // Check if critical components are ready
      let ready = true;
      let reason = '';

      try {
        // Must be able to connect to database
        await env.DB.prepare('SELECT 1').run();
      } catch (error) {
        ready = false;
        reason = 'Database connection failed';
      }

      if (ready) {
        return Response.json({ ready: true, timestamp: Date.now() });
      } else {
        return Response.json(
          { ready: false, reason, timestamp: Date.now() },
          { status: 503 }
        );
      }
    }
  }
};
```

### Liveness Check

```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    if (request.url.endsWith('/health/alive')) {
      // Simple check that worker is responsive
      return Response.json({
        alive: true,
        timestamp: Date.now()
      });
    }
  }
};
```

## Monitoring Integration

### Prometheus

```typescript
// Export metrics in Prometheus format
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    if (request.url.endsWith('/metrics')) {
      const health = await healthCheck(env);

      // Convert to Prometheus format
      const metrics = [
        `conductor_health{status="${health.status}"} 1`,
        `conductor_uptime_ms ${health.uptime}`,
        ...Object.entries(health.components).map(
          ([name, status]) =>
            `conductor_component_health{component="${name}"} ${status === 'ok' ? 1 : 0}`
        )
      ].join('\n');

      return new Response(metrics, {
        headers: { 'Content-Type': 'text/plain' }
      });
    }
  }
};
```

### Datadog

```typescript
// Send health metrics to Datadog
async function sendHealthMetrics(env: Env): Promise<void> {
  const health = await healthCheck(env);

  await fetch('https://api.datadoghq.com/api/v1/series', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'DD-API-KEY': env.DATADOG_API_KEY
    },
    body: JSON.stringify({
      series: [
        {
          metric: 'conductor.health.status',
          points: [[Date.now() / 1000, health.status === 'healthy' ? 1 : 0]],
          type: 'gauge',
          tags: [`version:${health.version}`]
        }
      ]
    })
  });
}
```

## Alerting

### Slack Notification

```yaml
# Health check ensemble
name: health-monitor
description: Monitor system health and alert

flow:
  - member: check-health
    type: Function

  - member: alert-if-unhealthy
    condition: ${check-health.output.status !== 'healthy'}
    type: API
    config:
      url: "${env.SLACK_WEBHOOK_URL}"
      method: POST
    input:
      body:
        text: "⚠️ Conductor health check failed"
        blocks:
          - type: "section"
            text:
              type: "mrkdwn"
              text: |
                *Status:* ${check-health.output.status}
                *Components:* ${JSON.stringify(check-health.output.components)}
```

### PagerDuty

```yaml
- member: page-oncall
  condition: ${health.status === 'unhealthy'}
  type: API
  config:
    url: "https://events.pagerduty.com/v2/enqueue"
    method: POST
  input:
    body:
      routing_key: ${env.PAGERDUTY_KEY}
      event_action: "trigger"
      payload:
        summary: "Conductor system unhealthy"
        severity: "critical"
        source: "conductor-health-check"
```

## Best Practices

1. **Fast health checks** - Keep under 100ms for quick responses
2. **Check critical components** - Database, KV, AI providers
3. **Return appropriate status codes** - 200 for healthy, 503 for unhealthy
4. **Include component details** - Help diagnose issues
5. **Set up monitoring** - Alert on health failures
6. **Test health endpoints** - Verify they work correctly
7. **Document expected behavior** - What "healthy" means
8. **Use readiness probes** - For load balancers and orchestrators
9. **Log health checks** - Track health over time
10. **Include version info** - Know what's deployed

## Related Documentation

<CardGroup cols={2}>
  <Card
    title="Monitoring Guide"
    icon="chart-line"
    href="/conductor/guides/monitoring"
  >
    System monitoring and observability
  </Card>

  <Card
    title="HTTP API Overview"
    icon="globe"
    href="/conductor-api/http/overview"
  >
    API documentation
  </Card>

  <Card
    title="Deployment Guide"
    icon="rocket"
    href="/conductor/guides/deployment"
  >
    Deploy to production
  </Card>

  <Card
    title="Troubleshooting"
    icon="wrench"
    href="/conductor/guides/troubleshooting"
  >
    Debug health issues
  </Card>
</CardGroup>
