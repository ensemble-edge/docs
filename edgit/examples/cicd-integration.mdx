---
title: "CI/CD Integration"
description: "Automate versioning and deployment in CI/CD pipelines"
---

> **Product**: Edgit
> **Version**: v1.0.0
> **Last Updated**: 2025-11-05

## Overview

Edgit integrates seamlessly with CI/CD pipelines to automate component versioning, tagging, and deployment. This guide shows you how to set up automated workflows in popular CI/CD platforms.

## GitHub Actions

### Basic Workflow

Automatically version and deploy components on every push to main:

```yaml .github/workflows/edgit-deploy.yml
name: Edgit Component Deployment

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for versioning

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Edgit
        run: npm install -g @ensemble/edgit

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: List changed components
        id: changes
        run: |
          edgit discover scan --json > changed.json
          echo "changes=$(cat changed.json)" >> $GITHUB_OUTPUT

      - name: Create version tags
        if: github.ref == 'refs/heads/main'
        run: |
          # Auto-increment patch version for changed components
          for component in $(edgit components list --names); do
            # Get latest version
            latest=$(edgit tag list $component | grep "^v" | tail -1)

            if [ -z "$latest" ]; then
              # First version
              edgit tag create $component v1.0.0
            else
              # Increment patch version (simplified)
              edgit tag create $component v1.0.${{ github.run_number }}
            fi
          done

      - name: Push tags
        if: github.ref == 'refs/heads/main'
        run: edgit tag push --force
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### Environment-Specific Deployment

Deploy to staging and production environments:

```yaml .github/workflows/edgit-environments.yml
name: Multi-Environment Deployment

on:
  push:
    branches:
      - main
      - staging

jobs:
  deploy-staging:
    if: github.ref == 'refs/heads/staging'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup and Install Edgit
        run: |
          npm install -g @ensemble/edgit
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Deploy to staging
        run: |
          for component in $(edgit components list --names); do
            latest=$(edgit tag list $component | grep "^v" | tail -1)
            if [ -n "$latest" ]; then
              edgit deploy set $component $latest --to staging
            fi
          done

      - name: Push deployment tags
        run: git push origin --tags --force

  deploy-production:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup and Install Edgit
        run: |
          npm install -g @ensemble/edgit
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Deploy to production
        run: |
          for component in $(edgit components list --names); do
            # Get staging version
            staging_sha=$(git rev-parse components/$component/staging)
            staging_version=$(edgit tag list $component | grep "^v" | while read tag; do
              tag_sha=$(git rev-parse components/$component/$tag)
              if [ "$tag_sha" = "$staging_sha" ]; then
                echo $tag
                break
              fi
            done | tail -1)

            if [ -n "$staging_version" ]; then
              echo "Promoting $component:$staging_version to production"
              edgit deploy set $component $staging_version --to production
            fi
          done

      - name: Push deployment tags
        run: git push origin --tags --force
```

### Component-Specific Workflows

Deploy specific components based on changed files:

```yaml .github/workflows/component-specific.yml
name: Component-Specific Deployment

on:
  push:
    branches: [main]
    paths:
      - 'src/functions/**'
      - 'src/agents/**'
      - 'config/**'

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      components: ${{ steps.detect.outputs.components }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Edgit
        run: npm install -g @ensemble/edgit

      - name: Detect changed components
        id: detect
        run: |
          # Get changed files
          changed_files=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})

          # Find components affected by changes
          components=()
          for file in $changed_files; do
            component=$(edgit components list --json | jq -r ".[] | select(.path == \"$file\") | .name")
            if [ -n "$component" ]; then
              components+=($component)
            fi
          done

          # Output unique components as JSON array
          echo "components=$(printf '%s\n' "${components[@]}" | sort -u | jq -R . | jq -s .)" >> $GITHUB_OUTPUT

  deploy-component:
    needs: detect-changes
    if: needs.detect-changes.outputs.components != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        component: ${{ fromJson(needs.detect-changes.outputs.components) }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup and Install Edgit
        run: |
          npm install -g @ensemble/edgit
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Version and deploy component
        run: |
          component="${{ matrix.component }}"
          version="v1.0.${{ github.run_number }}"

          echo "Versioning $component as $version"
          edgit tag create $component $version
          edgit deploy set $component $version --to production

      - name: Push tags
        run: git push origin --tags --force
```

### AI-Powered Commit Messages

Use Edgit's AI features in CI:

```yaml .github/workflows/ai-commits.yml
name: AI-Powered Commits

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  suggest-commit:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Edgit
        run: npm install -g @ensemble/edgit

      - name: Generate commit message suggestion
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          # Get PR diff
          git fetch origin pull/${{ github.event.pull_request.number }}/head:pr-${{ github.event.pull_request.number }}
          git checkout pr-${{ github.event.pull_request.number }}

          # Generate AI commit message
          message=$(edgit commit --dry-run)

          # Post as PR comment
          gh pr comment ${{ github.event.pull_request.number }} --body "### ðŸ¤– Suggested Commit Message\n\n\`\`\`\n$message\n\`\`\`"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## GitLab CI

### Basic Pipeline

```yaml .gitlab-ci.yml
stages:
  - test
  - version
  - deploy

variables:
  EDGIT_VERSION: "latest"

before_script:
  - npm install -g @ensemble/edgit@$EDGIT_VERSION
  - git config user.name "gitlab-ci"
  - git config user.email "gitlab-ci@example.com"

test:
  stage: test
  script:
    - npm test
  only:
    - merge_requests
    - main

version:components:
  stage: version
  script:
    - |
      for component in $(edgit components list --names); do
        version="v1.0.$CI_PIPELINE_IID"
        echo "Versioning $component as $version"
        edgit tag create $component $version
      done
    - git push origin --tags
  only:
    - main
  tags:
    - docker

deploy:staging:
  stage: deploy
  script:
    - |
      for component in $(edgit components list --names); do
        latest=$(edgit tag list $component | grep "^v" | tail -1)
        if [ -n "$latest" ]; then
          edgit deploy set $component $latest --to staging
        fi
      done
    - git push origin --tags --force
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - main
  tags:
    - docker

deploy:production:
  stage: deploy
  script:
    - |
      for component in $(edgit components list --names); do
        staging_version=$(git describe --tags --match "components/$component/staging")
        if [ -n "$staging_version" ]; then
          edgit deploy promote $component --from staging --to production
        fi
      done
    - git push origin --tags --force
  environment:
    name: production
    url: https://example.com
  when: manual
  only:
    - main
  tags:
    - docker
```

### Multi-Project Pipeline

For monorepo projects with multiple components:

```yaml .gitlab-ci.yml
stages:
  - discover
  - version
  - deploy

discover:changes:
  stage: discover
  script:
    - npm install -g @ensemble/edgit
    - edgit discover scan --json > changes.json
    - cat changes.json
  artifacts:
    paths:
      - changes.json
    expire_in: 1 hour
  only:
    - main

.version:template:
  stage: version
  script:
    - npm install -g @ensemble/edgit
    - git config user.name "gitlab-ci"
    - git config user.email "gitlab-ci@example.com"
    - |
      component="$COMPONENT_NAME"
      version="v1.0.$CI_PIPELINE_IID"
      echo "Versioning $component as $version"
      edgit tag create $component $version
      git push origin components/$component/$version
  only:
    - main

version:functions:
  extends: .version:template
  variables:
    COMPONENT_NAME: "my-function"
  needs: ["discover:changes"]

version:agents:
  extends: .version:template
  variables:
    COMPONENT_NAME: "my-agent"
  needs: ["discover:changes"]
```

## CircleCI

### Configuration

```yaml .circleci/config.yml
version: 2.1

executors:
  node-executor:
    docker:
      - image: cimg/node:18.0
    working_directory: ~/project

commands:
  setup-edgit:
    steps:
      - checkout
      - run:
          name: Install Edgit
          command: npm install -g @ensemble/edgit
      - run:
          name: Configure Git
          command: |
            git config user.name "circleci"
            git config user.email "circleci@example.com"

jobs:
  version-components:
    executor: node-executor
    steps:
      - setup-edgit
      - run:
          name: Create version tags
          command: |
            for component in $(edgit components list --names); do
              version="v1.0.$CIRCLE_BUILD_NUM"
              edgit tag create $component $version
            done
      - run:
          name: Push tags
          command: git push origin --tags

  deploy-staging:
    executor: node-executor
    steps:
      - setup-edgit
      - run:
          name: Deploy to staging
          command: |
            for component in $(edgit components list --names); do
              latest=$(edgit tag list $component | grep "^v" | tail -1)
              edgit deploy set $component $latest --to staging
            done
      - run:
          name: Push deployment tags
          command: git push origin --tags --force

  deploy-production:
    executor: node-executor
    steps:
      - setup-edgit
      - run:
          name: Deploy to production
          command: |
            for component in $(edgit components list --names); do
              edgit deploy promote $component --from staging --to production
            done
      - run:
          name: Push deployment tags
          command: git push origin --tags --force

workflows:
  version: 2
  build-and-deploy:
    jobs:
      - version-components:
          filters:
            branches:
              only: main
      - deploy-staging:
          requires:
            - version-components
          filters:
            branches:
              only: main
      - deploy-production:
          requires:
            - deploy-staging
          filters:
            branches:
              only: main
          type: approval
```

## Jenkins

### Declarative Pipeline

```groovy Jenkinsfile
pipeline {
    agent any

    environment {
        GIT_AUTHOR_NAME = 'jenkins'
        GIT_AUTHOR_EMAIL = 'jenkins@example.com'
        GIT_COMMITTER_NAME = 'jenkins'
        GIT_COMMITTER_EMAIL = 'jenkins@example.com'
    }

    stages {
        stage('Setup') {
            steps {
                sh 'npm install -g @ensemble/edgit'
            }
        }

        stage('Version Components') {
            when {
                branch 'main'
            }
            steps {
                script {
                    def components = sh(
                        script: 'edgit components list --names',
                        returnStdout: true
                    ).trim().split('\n')

                    components.each { component ->
                        def version = "v1.0.${env.BUILD_NUMBER}"
                        sh "edgit tag create ${component} ${version}"
                    }

                    sh 'git push origin --tags'
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                branch 'main'
            }
            steps {
                script {
                    def components = sh(
                        script: 'edgit components list --names',
                        returnStdout: true
                    ).trim().split('\n')

                    components.each { component ->
                        def latest = sh(
                            script: "edgit tag list ${component} | grep '^v' | tail -1",
                            returnStdout: true
                        ).trim()

                        if (latest) {
                            sh "edgit deploy set ${component} ${latest} --to staging"
                        }
                    }

                    sh 'git push origin --tags --force'
                }
            }
        }

        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                input message: 'Deploy to production?', ok: 'Deploy'

                script {
                    def components = sh(
                        script: 'edgit components list --names',
                        returnStdout: true
                    ).trim().split('\n')

                    components.each { component ->
                        sh "edgit deploy promote ${component} --from staging --to production"
                    }

                    sh 'git push origin --tags --force'
                }
            }
        }
    }

    post {
        always {
            sh 'edgit deploy status'
        }
        failure {
            echo 'Deployment failed!'
        }
        success {
            echo 'Deployment successful!'
        }
    }
}
```

## Best Practices

<AccordionGroup>
  <Accordion icon="shield" title="Authentication">
    **SSH Keys**: Use SSH keys for Git authentication in CI/CD

    ```yaml
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
    ```

    **Deploy Keys**: Create deploy keys with write access for tag pushing

    **Personal Access Tokens**: Use fine-grained tokens with `repo` scope
  </Accordion>

  <Accordion icon="lock" title="Security">
    **Protect secrets**: Never commit API keys or tokens

    ```yaml
    # Use secrets for sensitive data
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    ```

    **Limit permissions**: Use minimal required permissions

    **Audit deployments**: Keep deployment logs for compliance
  </Accordion>

  <Accordion icon="rocket" title="Performance">
    **Shallow clones**: Use `fetch-depth: 1` for faster checkouts (except when versioning)

    **Cache dependencies**: Cache npm packages

    ```yaml
    - name: Cache npm
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
    ```

    **Parallel jobs**: Deploy components in parallel when possible
  </Accordion>

  <Accordion icon="chart-line" title="Monitoring">
    **Deployment notifications**: Send alerts on successful/failed deployments

    **Status checks**: Add deployment status to PR checks

    **Metrics**: Track deployment frequency and success rate

    ```yaml
    - name: Notify Slack
      if: failure()
      uses: slackapi/slack-github-action@v1
      with:
        payload: |
          {
            "text": "Deployment failed for ${{ github.repository }}"
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
    ```
  </Accordion>
</AccordionGroup>

## Testing Strategies

### Pre-Deployment Testing

```yaml
test-before-deploy:
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v4

    - name: Run component tests
      run: |
        for component in $(edgit components list --names); do
          echo "Testing $component"
          # Run component-specific tests
          npm test -- --component=$component
        done

    - name: Validate components
      run: edgit discover scan --validate
```

### Smoke Testing

```yaml
smoke-test:
  needs: deploy-staging
  runs-on: ubuntu-latest
  steps:
    - name: Smoke test staging
      run: |
        for component in $(edgit components list --names); do
          version=$(git describe --tags --match "components/$component/staging")
          echo "Testing $component@$version"
          # Run smoke tests
          curl -f https://staging.example.com/health/$component || exit 1
        done
```

### Rollback on Failure

```yaml
deploy-with-rollback:
  runs-on: ubuntu-latest
  steps:
    - name: Deploy to production
      id: deploy
      run: |
        edgit deploy promote my-component --from staging --to production
        git push origin --tags --force

    - name: Health check
      id: health
      run: |
        sleep 30  # Wait for deployment
        curl -f https://example.com/health/my-component

    - name: Rollback on failure
      if: failure()
      run: |
        edgit deploy rollback my-component --env production
        git push origin --tags --force
```

## Troubleshooting

<AccordionGroup>
  <Accordion title="Git push fails with 'authentication failed'">
    **Problem**: CI doesn't have permission to push tags

    **Solutions**:
    - Use SSH keys instead of HTTPS
    - Add deploy key with write access
    - Use personal access token with `repo` scope
    - Configure Git credentials in CI environment
  </Accordion>

  <Accordion title="Tag already exists error">
    **Problem**: Trying to create version tag that exists

    **Solutions**:
    - Use `$CI_PIPELINE_ID` or `$GITHUB_RUN_NUMBER` for unique versions
    - Check existing tags before creating: `edgit tag list component`
    - Use deployment tags (moveable) instead of version tags
  </Accordion>

  <Accordion title="Components not detected">
    **Problem**: `edgit components list` returns empty

    **Solutions**:
    - Ensure `.edgit/components.json` is committed
    - Run `edgit init` if registry doesn't exist
    - Use full Git checkout with history
  </Accordion>

  <Accordion title="AI commit messages failing">
    **Problem**: OpenAI API key not working

    **Solutions**:
    - Verify `OPENAI_API_KEY` secret is set
    - Check API key has sufficient credits
    - Use manual commit messages as fallback
    - Test key locally first
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Monorepo Workflow"
    icon="folder-tree"
    href="/edgit/examples/monorepo-workflow"
  >
    Managing multiple components in a monorepo
  </Card>

  <Card
    title="Deployment Guide"
    icon="rocket"
    href="/edgit/guides/deployment"
  >
    Component deployment strategies
  </Card>

  <Card
    title="Versioning Guide"
    icon="tag"
    href="/edgit/guides/versioning"
  >
    Semantic versioning with Git tags
  </Card>

  <Card
    title="Troubleshooting"
    icon="wrench"
    href="/edgit/guides/troubleshooting"
  >
    Common issues and solutions
  </Card>
</CardGroup>
