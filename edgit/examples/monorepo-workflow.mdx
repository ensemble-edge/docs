---
title: "Monorepo Workflow"
description: "Managing multiple components in a monorepo with independent versioning"
---

> **Product**: Edgit
> **Version**: v1.0.0
> **Last Updated**: 2025-11-05

## Overview

Edgit excels at managing monorepos with dozens or hundreds of components. Each component can be versioned, tagged, and deployed independently while sharing a single Git repository.

## Why Edgit for Monorepos?

<CardGroup cols={2}>
  <Card title="Independent Versioning" icon="tag">
    Each component has its own version history. Ship `function-a` v2.0.0 while `function-b` stays at v1.0.0.
  </Card>

  <Card title="No Version Files" icon="file-slash">
    No `package.json` or `version.txt` files to maintain. Versions live in Git tags.
  </Card>

  <Card title="Zero Merge Conflicts" icon="shield-check">
    Since versions are tags (not files), no merge conflicts when multiple components are versioned.
  </Card>

  <Card title="Selective Deployment" icon="rocket">
    Deploy only the components that changed, not the entire monorepo.
  </Card>
</CardGroup>

## Example Monorepo Structure

```
my-monorepo/
├── .edgit/
│   └── components.json          # Component registry
├── src/
│   ├── functions/
│   │   ├── auth.ts              # Component: auth
│   │   ├── payments.ts          # Component: payments
│   │   └── notifications.ts     # Component: notifications
│   ├── agents/
│   │   ├── support-bot.ts       # Component: support-bot
│   │   └── sales-agent.ts       # Component: sales-agent
│   └── shared/
│       ├── utils.ts             # Shared utilities
│       └── types.ts             # Shared types
├── config/
│   ├── app.json                 # Component: app-config
│   └── database.json            # Component: db-config
└── package.json
```

## Setting Up a Monorepo

### Initialize Edgit

```bash
cd my-monorepo
edgit init
```

This creates `.edgit/components.json`:

```json
{
  "version": "1.0",
  "components": {},
  "updated": "2025-11-05T10:00:00.000Z"
}
```

### Register Components

Register all components in your monorepo:

```bash
# Register functions
edgit components add auth src/functions/auth.ts function \
  --description "Authentication service"

edgit components add payments src/functions/payments.ts function \
  --description "Payment processing"

edgit components add notifications src/functions/notifications.ts function \
  --description "Notification system"

# Register agents
edgit components add support-bot src/agents/support-bot.ts agent \
  --description "Customer support AI"

edgit components add sales-agent src/agents/sales-agent.ts agent \
  --description "Sales automation AI"

# Register configs
edgit components add app-config config/app.json config \
  --description "Application configuration"

edgit components add db-config config/database.json config \
  --description "Database configuration"
```

### Commit Registry

```bash
edgit add .edgit/
edgit commit -m "chore: register all components"
edgit push
```

## Independent Versioning Workflow

### Versioning Individual Components

When you update a component, version it independently:

```bash
# Update auth function
vim src/functions/auth.ts
edgit add src/functions/auth.ts
edgit commit -m "feat(auth): add OAuth2 support"

# Create version tag
edgit tag create auth v2.0.0

# Push
edgit push origin components/auth/v2.0.0
```

Other components remain at their current versions:
- `auth`: v2.0.0 (just updated)
- `payments`: v1.5.0 (unchanged)
- `notifications`: v1.3.0 (unchanged)

### Versioning Multiple Components

When changes affect multiple components:

```bash
# Update shared utilities
vim src/shared/utils.ts
vim src/functions/auth.ts
vim src/functions/payments.ts

edgit add .
edgit commit -m "refactor: optimize shared utilities"

# Version affected components
edgit tag create auth v2.0.1
edgit tag create payments v1.5.1

# Push all tags
edgit tag push --force
```

### Viewing Component Versions

```bash
# List all components
edgit components list

# Output:
# function/auth (src/functions/auth.ts)
#   Versions: v1.0.0, v2.0.0, v2.0.1
#
# function/payments (src/functions/payments.ts)
#   Versions: v1.0.0, v1.5.0, v1.5.1
#
# function/notifications (src/functions/notifications.ts)
#   Versions: v1.0.0, v1.3.0

# Show specific component
edgit components show auth
```

## Dependency Management

### Tracking Component Dependencies

Define component dependencies in the registry:

```json .edgit/components.json
{
  "version": "1.0",
  "components": {
    "auth": {
      "type": "function",
      "path": "src/functions/auth.ts",
      "description": "Authentication service",
      "dependencies": []
    },
    "payments": {
      "type": "function",
      "path": "src/functions/payments.ts",
      "description": "Payment processing",
      "dependencies": ["auth"]
    },
    "notifications": {
      "type": "function",
      "path": "src/functions/notifications.ts",
      "description": "Notification system",
      "dependencies": ["auth"]
    }
  }
}
```

### Versioning with Dependencies

When a dependency changes, version all dependent components:

```bash
# Update auth (breaking change)
vim src/functions/auth.ts
edgit add src/functions/auth.ts
edgit commit -m "feat(auth)!: change authentication API"
edgit tag create auth v3.0.0

# Update dependent components
vim src/functions/payments.ts
vim src/functions/notifications.ts
edgit add src/functions/
edgit commit -m "feat: update to auth v3.0.0"

# Version dependents
edgit tag create payments v2.0.0
edgit tag create notifications v2.0.0

# Push all
edgit push origin --tags
```

### Dependency Graph Script

Create a script to visualize dependencies:

```bash scripts/show-dependencies.sh
#!/bin/bash
# Show component dependency graph

echo "Component Dependencies:"
echo ""

jq -r '.components | to_entries[] | "\(.key): \(.value.dependencies // [] | join(", "))"' \
  .edgit/components.json
```

Run it:

```bash
chmod +x scripts/show-dependencies.sh
./scripts/show-dependencies.sh

# Output:
# Component Dependencies:
#
# auth:
# payments: auth
# notifications: auth
# support-bot: auth, notifications
# sales-agent: auth
```

## Selective Deployment

### Deploy Only Changed Components

Deploy components selectively based on changes:

```bash
# Get changed files since last deployment
changed_files=$(git diff --name-only origin/main)

# Find affected components
for file in $changed_files; do
  component=$(edgit components list --json | \
    jq -r ".[] | select(.path == \"$file\") | .name")

  if [ -n "$component" ]; then
    echo "Deploying $component"

    # Get latest version
    version=$(edgit tag list $component | grep "^v" | tail -1)

    # Deploy to staging
    edgit deploy set $component $version --to staging
  fi
done

# Push deployment tags
edgit push origin --tags --force
```

### Environment-Specific Deployments

Different components in different environments:

```bash
# Deploy to staging
edgit deploy set auth v2.0.0 --to staging
edgit deploy set payments v1.5.0 --to staging
edgit deploy set notifications v1.3.0 --to staging

# Deploy to production (only stable versions)
edgit deploy set auth v1.9.0 --to production
edgit deploy set payments v1.4.0 --to production
edgit deploy set notifications v1.2.0 --to production

# View deployment status
edgit deploy status

# Output:
# auth
#   staging: v2.0.0
#   production: v1.9.0
#
# payments
#   staging: v1.5.0
#   production: v1.4.0
```

### Batch Deployment Script

```bash scripts/deploy-all.sh
#!/bin/bash
# Deploy all components to an environment

environment=$1
if [ -z "$environment" ]; then
  echo "Usage: $0 <environment>"
  exit 1
fi

for component in $(edgit components list --names); do
  # Get latest version
  latest=$(edgit tag list $component | grep "^v" | tail -1)

  if [ -n "$latest" ]; then
    echo "Deploying $component $latest to $environment"
    edgit deploy set $component $latest --to $environment
  else
    echo "Skipping $component (no versions)"
  fi
done

edgit push origin --tags --force
```

Use it:

```bash
./scripts/deploy-all.sh staging
./scripts/deploy-all.sh production
```

## CI/CD Integration

### GitHub Actions Workflow

```yaml .github/workflows/monorepo.yml
name: Monorepo Component Management

on:
  push:
    branches: [main]

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      components: ${{ steps.detect.outputs.components }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Edgit
        run: npm install -g @ensemble/edgit

      - name: Detect changed components
        id: detect
        run: |
          changed_files=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
          components=()

          for file in $changed_files; do
            component=$(edgit components list --json | \
              jq -r ".[] | select(.path == \"$file\") | .name")
            if [ -n "$component" ]; then
              components+=($component)
            fi
          done

          unique_components=$(printf '%s\n' "${components[@]}" | sort -u | jq -R . | jq -s .)
          echo "components=$unique_components" >> $GITHUB_OUTPUT

  version-and-deploy:
    needs: detect-changes
    if: needs.detect-changes.outputs.components != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        component: ${{ fromJson(needs.detect-changes.outputs.components) }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Edgit
        run: npm install -g @ensemble/edgit

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Version component
        run: |
          component="${{ matrix.component }}"
          version="v1.0.${{ github.run_number }}"

          echo "Versioning $component as $version"
          edgit tag create $component $version
          edgit deploy set $component $version --to staging

      - name: Push tags
        run: edgit push origin --tags --force
```

## Advanced Patterns

### Canary Deployments

Deploy to a canary environment first:

```bash
# Deploy to canary
edgit deploy set auth v2.0.0 --to canary

# Monitor metrics...
# If healthy, promote to production
edgit deploy promote auth --from canary --to production
```

### Blue-Green Deployments

Use deployment tags for blue-green:

```bash
# Deploy to blue environment
edgit deploy set auth v2.0.0 --to blue

# Test blue...
# Switch traffic (external to edgit)
# Then update green
edgit deploy set auth v2.0.0 --to green
```

### Rollback Strategy

Rollback individual components:

```bash
# Current state
edgit deploy status auth
# production: v2.0.0

# Something went wrong, rollback
edgit deploy rollback auth --env production

# Or rollback to specific version
edgit deploy rollback auth --env production --to v1.9.0

# Push
edgit push origin --tags --force
```

## Monorepo Best Practices

<AccordionGroup>
  <Accordion icon="folder-tree" title="Organization">
    **Group by type**: Organize components into folders by type

    ```
    src/
    ├── functions/     # All function components
    ├── agents/        # All agent components
    └── configs/       # All config components
    ```

    **Shared code**: Keep shared utilities separate

    ```
    src/
    ├── shared/        # Not registered as components
    └── functions/     # Import from shared/
    ```

    **Clear naming**: Use descriptive component names
    - Good: `payment-processor`, `email-notifications`
    - Bad: `func1`, `helper`
  </Accordion>

  <Accordion icon="tag" title="Versioning Strategy">
    **Semantic versioning**: Follow semver strictly
    - `v1.0.0` → `v1.0.1`: Bug fixes
    - `v1.0.0` → `v1.1.0`: New features
    - `v1.0.0` → `v2.0.0`: Breaking changes

    **Version dependencies together**: When a shared component changes, version all dependents

    **Tag frequently**: Create version tags for every significant change
  </Accordion>

  <Accordion icon="rocket" title="Deployment">
    **Test in staging first**: Always deploy to staging before production

    **Gradual rollout**: Use canary deployments for risky changes

    **Coordinate deployments**: Deploy dependent components together

    **Keep deployment logs**: Track what's deployed where
  </Accordion>

  <Accordion icon="shield" title="Safety">
    **Branch protection**: Protect main branch, require PR reviews

    **Automated tests**: Test components before versioning

    **Rollback plan**: Document rollback procedures

    **Monitor deployments**: Set up alerts for deployment failures
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Too many components to manage">
    **Problem**: Hundreds of components making commands slow

    **Solutions**:
    - Use component filters: `edgit components list --type function`
    - Create component groups in registry metadata
    - Deploy by directory pattern
    - Use selective CI/CD workflows
  </Accordion>

  <Accordion title="Dependency version mismatch">
    **Problem**: Component A depends on outdated version of B

    **Solutions**:
    - Track dependency versions in metadata
    - Create pre-deploy validation script
    - Use automated dependency updates
    - Document compatibility matrix
  </Accordion>

  <Accordion title="Deployment order matters">
    **Problem**: Need to deploy components in specific order

    **Solutions**:
    - Document deployment order in README
    - Create deployment orchestration script
    - Use CI/CD job dependencies
    - Add deployment order to component metadata
  </Accordion>

  <Accordion title="Merge conflicts in registry">
    **Problem**: Multiple branches modify `.edgit/components.json`

    **Solutions**:
    - Register components in separate PRs
    - Use registry merge tool
    - Lock registry changes to one person
    - Automate component registration via CI
  </Accordion>
</AccordionGroup>

## Real-World Example

### Serverless Functions Monorepo

```bash
# Repository structure
my-saas/
├── .edgit/
│   └── components.json
├── functions/
│   ├── api-gateway/
│   │   └── index.ts          # Component: api-gateway
│   ├── user-auth/
│   │   └── index.ts          # Component: user-auth
│   ├── subscription-billing/
│   │   └── index.ts          # Component: subscription-billing
│   └── email-service/
│       └── index.ts          # Component: email-service
└── shared/
    └── lib/                   # Shared utilities (not components)

# Workflow
# 1. Developer updates billing function
vim functions/subscription-billing/index.ts
edgit add functions/subscription-billing/
edgit commit -m "feat(billing): add annual subscription tier"

# 2. Version and deploy to staging
edgit tag create subscription-billing v2.1.0
edgit deploy set subscription-billing v2.1.0 --to staging
edgit push origin --tags --force

# 3. Test in staging
curl https://staging-api.myapp.com/billing/health

# 4. Promote to production
edgit deploy promote subscription-billing --from staging --to production
edgit push origin --tags --force

# 5. Verify deployment
edgit deploy status subscription-billing
# Output:
#   staging: v2.1.0
#   production: v2.1.0
```

## Next Steps

<CardGroup cols={2}>
  <Card
    title="CI/CD Integration"
    icon="gear"
    href="/edgit/examples/cicd-integration"
  >
    Automate monorepo workflows with CI/CD
  </Card>

  <Card
    title="Deployment Guide"
    icon="rocket"
    href="/edgit/guides/deployment"
  >
    Advanced deployment strategies
  </Card>

  <Card
    title="Component Types"
    icon="cube"
    href="/edgit/guides/component-types"
  >
    Understanding component categories
  </Card>

  <Card
    title="Troubleshooting"
    icon="wrench"
    href="/edgit/guides/troubleshooting"
  >
    Common issues and solutions
  </Card>
</CardGroup>
