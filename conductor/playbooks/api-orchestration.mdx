---
title: "API Orchestration"
description: "Call multiple APIs, handle auth, retries, and transform responses. Build API workflows that just work."
---

## Basic Pattern

```yaml
ensemble: api-workflow

agents:
  # Call APIs in sequence or parallel
  - name: api-1
    agent: fetcher
    inputs:
      url: https://api1.example.com/data

  - name: api-2
    agent: fetcher
    inputs:
      url: https://api2.example.com/data
      body: ${api-1.output.body}

  # Transform and combine
  - name: combine
    agent: transformer
    inputs:
      data:
        source1: ${api-1.output.body}
        source2: ${api-2.output.body}
```

## OAuth Flow

```yaml
ensemble: oauth-api-call

agents:
  # Get access token
  - name: get-token
    agent: fetcher
    inputs:
      url: https://auth.example.com/oauth/token
      method: POST
      body:
        grant_type: client_credentials
        client_id: ${env.CLIENT_ID}
        client_secret: ${env.CLIENT_SECRET}
    cache:
      ttl: 3600
      key: oauth-token

  # Use token
  - name: api-call
    agent: fetcher
    inputs:
      url: https://api.example.com/data
      headers:
        Authorization: Bearer ${get-token.output.body.access_token}
```

## Parallel API Aggregation

```yaml
ensemble: aggregate-apis

agents:
  # Call multiple APIs in parallel
  - name: weather
    agent: fetcher
    inputs:
      url: https://api.weather.com/current?city=${input.city}

  - name: news
    agent: fetcher
    inputs:
      url: https://api.news.com/local?city=${input.city}

  - name: events
    agent: fetcher
    inputs:
      url: https://api.events.com/upcoming?city=${input.city}

  # Combine results
  - name: combine
    operation: code
    config:
      script: scripts/combine-city-data
    input:
      city: ${input.city}
      weather: ${weather.output.body}
      news_articles: ${news.output.body.articles}
      events: ${events.output.body.events}

```typescript
// scripts/combine-city-data.ts
import type { AgentExecutionContext } from '@ensemble-edge/conductor'

export default function combineCityData(context: AgentExecutionContext) {
  const { city, weather, news_articles, events } = context.input

  return {
    city,
    weather,
    news: news_articles.slice(0, 5),
    events: events.slice(0, 10)
  }
}
```

## Webhook Handling

```yaml
ensemble: process-webhook

agents:
  # Validate webhook signature
  - name: validate
    operation: code
    config:
      script: scripts/validate-webhook-signature
    input:
      body: ${input.body}
      signature: ${input.headers['x-signature']}
      secret: ${env.WEBHOOK_SECRET}

  # Process if valid
  - name: process
    condition: ${validate.output.valid}
    operation: code
    config:
      script: scripts/process-webhook-data

```typescript
// scripts/validate-webhook-signature.ts
import type { AgentExecutionContext } from '@ensemble-edge/conductor'
import * as crypto from 'crypto'

export default function validateWebhookSignature(context: AgentExecutionContext) {
  const { body, signature, secret } = context.input

  const computedSignature = crypto
    .createHmac('sha256', secret)
    .update(JSON.stringify(body))
    .digest('hex')

  return {
    valid: computedSignature === signature
  }
}
```

```typescript
// scripts/process-webhook-data.ts
import type { AgentExecutionContext } from '@ensemble-edge/conductor'

export default function processWebhookData(context: AgentExecutionContext) {
  // Process webhook data
  return { processed: true }
}
```

```yaml
  # Forward to internal API
  - name: forward
    condition: ${process.executed}
    agent: fetcher
    inputs:
      url: ${env.INTERNAL_API_URL}
      method: POST
      body: ${input.body}
```

## Rate Limiting

```yaml
ensemble: rate-limited-api

agents:
  # Check rate limit
  - name: check-limit
    operation: storage
    config:
      type: kv
      action: get
      key: rate-limit-${input.user_id}

  # Allow if under limit
  - name: allow
    condition: ${!check-limit.output || check-limit.output.count < 100}
    agent: fetcher
    inputs:
      url: https://api.example.com/data

  # Update counter
  - name: update-limit
    condition: ${allow.executed}
    operation: storage
    config:
      type: kv
      action: put
      key: rate-limit-${input.user_id}
      value:
        count: ${(check-limit.output?.count || 0) + 1}
        reset_at: ${Date.now() + 3600000}
      ttl: 3600

  # Reject if over limit
  - name: reject
    condition: ${check-limit.output && check-limit.output.count >= 100}
    operation: code
    config:
      script: scripts/reject-rate-limited
    input:
      reset_at: ${check-limit.output.reset_at}
```

```typescript
// scripts/reject-rate-limited.ts
import type { AgentExecutionContext } from '@ensemble-edge/conductor'

export default function rejectRateLimited(context: AgentExecutionContext) {
  const { reset_at } = context.input
  return {
    error: 'Rate limit exceeded',
    retry_after: reset_at
  }
}
```

```yaml
```

## Circuit Breaker

```yaml
ensemble: circuit-breaker

agents:
  # Check circuit state
  - name: check-circuit
    operation: storage
    config:
      type: kv
      action: get
      key: circuit-${input.service}

  # Call if circuit closed
  - name: call-api
    condition: ${!check-circuit.output || check-circuit.output.state !== 'open'}
    agent: fetcher
    inputs:
      url: ${input.url}
    retry:
      maxAttempts: 3

  # Open circuit on failure
  - name: open-circuit
    condition: ${call-api.failed}
    operation: storage
    config:
      type: kv
      action: put
      key: circuit-${input.service}
      value:
        state: open
        opened_at: ${Date.now()}
      ttl: 60

  # Use fallback if circuit open
  - name: fallback
    condition: ${check-circuit.output?.state === 'open'}
    operation: code
    config:
      script: scripts/circuit-breaker-fallback

```typescript
// scripts/circuit-breaker-fallback.ts
import type { AgentExecutionContext } from '@ensemble-edge/conductor'

export default function circuitBreakerFallback(context: AgentExecutionContext) {
  return {
    error: 'Service unavailable',
    fallback: true
  }
}
```

## Next Steps

<CardGroup cols={2}>
  <Card title="fetcher Agent" icon="download" href="/conductor/agents/fetcher">
    HTTP requests
  </Card>
  <Card title="http Operation" icon="globe" href="/conductor/operations/http">
    Low-level HTTP
  </Card>
  <Card title="transformer Agent" icon="wand-magic-sparkles" href="/conductor/agents/transformer">
    Response transformation
  </Card>
  <Card title="Event-Driven" icon="bolt" href="/conductor/playbooks/event-driven-workflow">
    Webhooks and events
  </Card>
</CardGroup>
