---
title: "Your First Agent"
description: "Build custom reusable agents - the building blocks of your workflows"
---

## What's an Agent?

An agent is a reusable unit of work with:
- **Inputs**: Parameters it accepts
- **Operation**: What it does (code, think, http, storage, etc.)
- **Outputs**: Data it returns

Agents are auto-discovered from the `agents/` directory and can be used across multiple ensembles.

## Explore the Template Agent

Your project already includes a working agent! Let's explore `agents/hello/`:

```
agents/hello/
├── agent.yaml      # Agent configuration
└── index.ts        # Agent implementation
```

### agent.yaml

```yaml
name: hello
operation: code
description: Simple greeting function

schema:
  input:
    name: string
    style: string?
  output:
    message: string
```

This declares:
- **Operation type**: `code` (runs JavaScript/TypeScript)
- **Input schema**: Accepts `name` (required) and `style` (optional)
- **Output schema**: Returns a `message` string

### index.ts

```typescript
export default function hello({ name, style }: { name: string; style?: string }) {
  const styles = {
    formal: `Good day, ${name}. It is a pleasure to make your acquaintance.`,
    casual: `Hey ${name}! What's up?`,
    enthusiastic: `OMG ${name}! SO EXCITED TO MEET YOU!!!`
  };

  const message = style && style in styles
    ? styles[style as keyof typeof styles]
    : `Hello, ${name}! Welcome to Conductor.`;

  return { message };
}
```

Simple TypeScript function that returns an object matching the output schema.

## Understanding Operation Types

Agents use different operations based on what they need to do:

### operation: code

**When to use**: Run custom TypeScript/JavaScript logic
**Requires**: Function implementation in `index.ts`
**API keys needed**: ❌ No

```yaml
name: greeter
operation: code
description: Custom greeting logic

schema:
  input:
    name: string
  output:
    greeting: string
```

### operation: think

**When to use**: Call LLM models for reasoning, analysis, generation
**Requires**: Provider and model configuration
**API keys needed**: ✅ Yes (OpenAI, Anthropic) or Cloudflare Workers AI

```yaml
name: analyzer
operation: think
description: Analyze text with AI

config:
  provider: anthropic
  model: claude-3-5-sonnet-20241022
  prompt: |
    Analyze this text: ${input.text}
    Provide key insights.

schema:
  input:
    text: string
  output:
    analysis: string
```

### operation: http

**When to use**: Make HTTP requests to external APIs
**Requires**: URL and method configuration
**API keys needed**: Depends on API

```yaml
name: fetcher
operation: http
description: Fetch data from API

config:
  url: https://api.example.com/data
  method: GET
  headers:
    Authorization: Bearer ${env.API_KEY}

schema:
  output:
    data: object
```

### operation: data

**When to use**: Query databases (KV, D1, R2)
**Requires**: Database binding in wrangler.toml
**API keys needed**: ❌ No (uses Cloudflare bindings)

```yaml
name: db-query
operation: data
description: Query D1 database

config:
  type: d1
  query: SELECT * FROM users WHERE id = ?
  params:
    - ${input.user_id}

schema:
  input:
    user_id: string
  output:
    user: object
```

[See all operations ](/conductor/operations/overview)

## Test the Hello Agent

The template includes working tests. Let's look at `tests/basic.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { Executor, MemberLoader } from '@ensemble-edge/conductor';
import { stringify } from 'yaml';
import helloWorldYAML from '../ensembles/hello-world.yaml';
import greetConfig from '../agents/hello/agent.yaml';
import greetFunction from '../agents/hello';

describe('Hello Agent Test', () => {
  it('should execute successfully', async () => {
    // Setup with proper ExecutionContext mock
    const env = {} as Env;
    const ctx = {
      waitUntil: (promise: Promise<any>) => promise,
      passThroughOnException: () => {}
    } as ExecutionContext;

    const executor = new Executor({ env, ctx });
    const loader = new MemberLoader({ env, ctx });

    // Register hello agent
    const greetMember = loader.registerAgent(greetConfig, greetFunction);
    executor.registerAgent(greetMember);

    // Execute the ensemble
    const result = await executor.executeFromYAML(
      stringify(helloWorldYAML),
      { name: 'World' }
    );

    // Verify result
    expect(result.success).toBe(true);
    expect(result.value.output.greeting).toContain('Hello');
  });
});
```

Run it:
```bash
npm test
```

All tests should pass! ✅

## Create Your First Custom Agent

Now that you understand how agents work, let's create a new one.

### Step 1: Create Agent Directory

```bash
mkdir -p agents/greeter
```

### Step 2: Define the Agent

Create `agents/greeter/agent.yaml`:

```yaml
name: greeter
operation: code
description: Generates personalized greetings with different styles

schema:
  input:
    name: string
    time_of_day: string?
    language: string?
  output:
    greeting: string
    timestamp: number
```

### Step 3: Implement the Agent

Create `agents/greeter/index.ts`:

```typescript
export default function greeter({
  name,
  time_of_day = 'day',
  language = 'en'
}: {
  name: string;
  time_of_day?: string;
  language?: string;
}) {
  const greetings: Record<string, Record<string, string>> = {
    en: {
      morning: `Good morning, ${name}!`,
      afternoon: `Good afternoon, ${name}!`,
      evening: `Good evening, ${name}!`,
      day: `Hello, ${name}!`
    },
    es: {
      morning: `Buenos días, ${name}!`,
      afternoon: `Buenas tardes, ${name}!`,
      evening: `Buenas noches, ${name}!`,
      day: `Hola, ${name}!`
    },
    fr: {
      morning: `Bonjour, ${name}!`,
      afternoon: `Bon après-midi, ${name}!`,
      evening: `Bonsoir, ${name}!`,
      day: `Bonjour, ${name}!`
    }
  };

  const langGreetings = greetings[language] || greetings.en;
  const greeting = langGreetings[time_of_day] || langGreetings.day;

  return {
    greeting,
    timestamp: Date.now()
  };
}
```

### Step 4: Rebuild

Agents are auto-discovered at build time:

```bash
npm run build
```

### Step 5: Use Your Agent

Create `ensembles/greeting-workflow.yaml`:

```yaml
ensemble: greeting-workflow
description: Generate personalized greetings

agents:
  - name: greet
    operation: code
    config:
      handler: greeter  # Reference your new agent

output:
  greeting: ${greet.output.greeting}
  timestamp: ${greet.output.timestamp}
```

### Step 6: Test It

Create `tests/greeter.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { Executor, MemberLoader } from '@ensemble-edge/conductor';
import { stringify } from 'yaml';
import greetingWorkflow from '../ensembles/greeting-workflow.yaml';
import greeterConfig from '../agents/greeter/agent.yaml';
import greeterFunction from '../agents/greeter';

describe('Greeter Agent', () => {
  it('should generate greetings in different languages', async () => {
    const env = {} as Env;
    const ctx = {
      waitUntil: (promise: Promise<any>) => promise,
      passThroughOnException: () => {}
    } as ExecutionContext;

    const executor = new Executor({ env, ctx });
    const loader = new MemberLoader({ env, ctx });

    const greeterMember = loader.registerAgent(greeterConfig, greeterFunction);
    executor.registerAgent(greeterMember);

    const result = await executor.executeFromYAML(
      stringify(greetingWorkflow),
      { name: 'Alice', time_of_day: 'morning', language: 'es' }
    );

    expect(result.success).toBe(true);
    expect(result.value.output.greeting).toBe('Buenos días, Alice!');
  });
});
```

Run: `npm test`

## Agent with AI (operation: think)

Let's create an agent that uses AI for more complex logic.

### Create AI Analyzer Agent

Create `agents/analyzer/agent.yaml`:

```yaml
name: analyzer
operation: think
description: Analyzes text sentiment and extracts key themes

config:
  provider: anthropic
  model: claude-3-5-sonnet-20241022
  prompt: |
    Analyze the following text:

    ${input.text}

    Provide a JSON response with:
    - sentiment: positive, negative, or neutral
    - confidence: 0-1 score
    - themes: array of key themes
    - summary: one sentence summary

    Return only valid JSON.

schema:
  input:
    text: string
  output:
    sentiment: string
    confidence: number
    themes: array
    summary: string
```

**Note**: This requires an Anthropic API key in your environment.

### Use the Analyzer

Create `ensembles/analyze-text.yaml`:

```yaml
ensemble: analyze-text
description: Analyze text with AI

agents:
  - name: analyze
    operation: think
    config:
      provider: anthropic
      model: claude-3-5-sonnet-20241022
      prompt: |
        Analyze: ${input.text}

output:
  analysis: ${analyze.output}
```

## Auto-Discovery

**Important**: Agents in the `agents/` directory are automatically discovered at build time.

**When you create a new agent**:
1. Create the directory: `agents/my-agent/`
2. Add `agent.yaml` and optionally `index.ts`
3. Rebuild: `npm run build`
4. Your agent is now available!

**No manual registration needed!**

## Agent Patterns

### Pattern 1: Simple Code Agent

Pure logic, no external dependencies:

```typescript
// agents/calculator/index.ts
export default function calculator({
  operation,
  a,
  b
}: {
  operation: string;
  a: number;
  b: number;
}) {
  const ops: Record<string, number> = {
    add: a + b,
    subtract: a - b,
    multiply: a * b,
    divide: b !== 0 ? a / b : 0
  };

  return {
    result: ops[operation] || 0
  };
}
```

### Pattern 2: HTTP Data Fetcher

Fetch from external APIs:

```yaml
name: weather-fetcher
operation: http
description: Fetch weather data

config:
  url: https://api.weather.com/current?city=${input.city}
  method: GET
  headers:
    Authorization: Bearer ${env.WEATHER_API_KEY}
  cache:
    ttl: 1800  # Cache for 30 minutes

schema:
  input:
    city: string
  output:
    temperature: number
    conditions: string
```

### Pattern 3: Database Query

Query Cloudflare D1:

```yaml
name: user-lookup
operation: data
description: Look up user by email

config:
  type: d1
  query: |
    SELECT id, name, email, created_at
    FROM users
    WHERE email = ?
    LIMIT 1
  params:
    - ${input.email}

schema:
  input:
    email: string
  output:
    user: object?
```

### Pattern 4: AI with Custom Logic

Combine AI with code:

```yaml
name: smart-responder
operation: think
description: Generate contextual responses

config:
  provider: anthropic
  model: claude-3-5-sonnet-20241022
  prompt: |
    User message: ${input.message}
    User history: ${input.history}

    Generate a helpful response that:
    1. Acknowledges their message
    2. References their history
    3. Provides actionable next steps

    Keep it under 50 words.

schema:
  input:
    message: string
    history: array
  output:
    response: string
```

## Best Practices

### 1. Keep Agents Focused

Each agent should do ONE thing well:
- ✅ `user-validator` - Validates user data
- ❌ `user-handler` - Validates, stores, sends email, logs (too much!)

### 2. Use Descriptive Names

- ✅ `email-sender`, `pdf-extractor`, `sentiment-analyzer`
- ❌ `helper`, `utils`, `processor`

### 3. Document Inputs/Outputs

Always define schemas:

```yaml
schema:
  input:
    user_id: string  # UUID of the user
    include_metadata: boolean  # Whether to include extra fields
  output:
    user: object  # User record with all fields
    metadata: object?  # Additional metadata if requested
```

### 4. Handle Errors Gracefully

```typescript
export default function myAgent({ input }: { input: string }) {
  try {
    // Your logic
    return { success: true, result: processedData };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}
```

### 5. Use Caching for HTTP Agents

```yaml
config:
  url: https://api.example.com/data
  cache:
    ttl: 3600  # Cache for 1 hour
```

Reduces API calls and improves performance!

### 6. Test Your Agents

Always write tests for custom agents:

```typescript
describe('My Agent', () => {
  it('should handle valid input', async () => {
    // Test success case
  });

  it('should handle invalid input', async () => {
    // Test error case
  });

  it('should respect timeout', async () => {
    // Test performance
  });
});
```

## Troubleshooting

<AccordionGroup>
  <Accordion title="Agent not found after creation">
    **Problem**: Created a new agent but it's not available

    **Fix**: Rebuild to trigger auto-discovery:
    ```bash
    npm run build
    ```

    Agents are discovered at build time, not runtime.
  </Accordion>

  <Accordion title="ExecutionContext errors in tests">
    **Problem**: `TypeError: this.ctx.waitUntil is not a function`

    **Fix**: Use proper ExecutionContext mock:
    ```typescript
    const ctx = {
      waitUntil: (promise: Promise<any>) => promise,
      passThroughOnException: () => {}
    } as ExecutionContext;
    ```
  </Accordion>

  <Accordion title="AI operation requires API key">
    **Problem**: `operation: think` fails with authentication error

    **Fix**: Add API key to wrangler.toml or environment:
    ```toml
    [vars]
    ANTHROPIC_API_KEY = "sk-ant-..."
    ```

    Or use Cloudflare Workers AI (no key needed):
    ```yaml
    config:
      provider: cloudflare
      model: '@cf/meta/llama-3.1-8b-instruct'
    ```
  </Accordion>

  <Accordion title="Operation type not supported">
    **Problem**: Want to use an operation that doesn't exist

    **Fix**: Use `operation: code` and implement in TypeScript:
    ```typescript
    export default async function myAgent({ input }) {
      // Your custom logic here
      const result = await customOperation(input);
      return { result };
    }
    ```

    Code operations can do anything TypeScript can do!
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Your First Ensemble" icon="diagram-project" href="/conductor/getting-started/your-first-ensemble">
    Combine agents into workflows
  </Card>

  <Card title="Operations Reference" icon="bolt" href="/conductor/operations/overview">
    Explore all operation types
  </Card>

  <Card title="Pre-built Agents" icon="cube" href="/conductor/agents/overview">
    Use ready-made agents
  </Card>

  <Card title="Testing Guide" icon="check-circle" href="/conductor/building/testing-observability">
    Write comprehensive tests
  </Card>
</CardGroup>

## Advanced: Versioning with Edgit (Optional)

If you want component-level versioning, you can use Edgit:

```bash
# Add agent to Edgit
edgit components add agent my-agent agents/my-agent/ --type=agent

# Tag a version
edgit tag create my-agent v1.0.0 --type=agent

# Reference versioned agent
```

```yaml
agents:
  - name: processor
    agent: my-agent@v1.0.0  # Specific version via Edgit
```

> **Note**: Edgit is optional. Standard git version control works great!

[Learn more about Edgit ](/edgit/overview)
