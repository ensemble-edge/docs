---
title: "Pre-built Agents"
description: "Production-ready agents you can drop into your ensembles. No boilerplate, no reinventing the wheel, just proven patterns for common workflows."
---

## Agent Types

Conductor provides three categories of pre-built agents:

1. **System Agents** - Built-in agents for core functionality (redirects, docs, fetching, validation)
2. **Debug Agents** - Development and testing utilities (echo, delay, inspect-context)
3. **Example Agents** - Reference implementations shipped with templates

## System Agents

Built-in agents that provide core infrastructure capabilities:

<CardGroup cols={2}>
  <Card title="redirect" icon="arrow-turn-up" href="/conductor/agents/redirect">
    URL redirect service with permanent, expiring, and single-use (magic) links
  </Card>
  <Card title="docs" icon="book" href="/conductor/agents/docs">
    Documentation generation and serving (OpenAPI, etc.)
  </Card>
  <Card title="fetch" icon="download" href="/conductor/agents/fetch">
    HTTP fetching with caching and retry logic
  </Card>
  <Card title="validate" icon="check-circle" href="/conductor/agents/validate">
    Data validation with multiple evaluation strategies
  </Card>
  <Card title="scrape" icon="spider-web" href="/conductor/agents/scrape">
    Web scraping with bot detection and HTML parsing
  </Card>
  <Card title="slug" icon="hashtag" href="/conductor/agents/slug">
    Generate URL-safe slugs from text
  </Card>
  <Card title="tools" icon="wrench" href="/conductor/agents/tools">
    MCP (Model Context Protocol) tools integration
  </Card>
  <Card title="queries" icon="database" href="/conductor/agents/queries">
    SQL query execution and formatting
  </Card>
</CardGroup>

## Debug Agents

Development utilities for testing and debugging workflows:

<CardGroup cols={2}>
  <Card title="echo" icon="reply" href="/conductor/agents/echo">
    Returns input unchanged - inspect data at any point in your flow
  </Card>
  <Card title="delay" icon="clock" href="/conductor/agents/delay">
    Add artificial delay to simulate slow operations
  </Card>
  <Card title="inspect-context" icon="magnifying-glass" href="/conductor/agents/inspect-context">
    Inspect execution context for debugging
  </Card>
</CardGroup>

## Pre-built Feature Agents

Ready-made agents for common workflows:

<CardGroup cols={2}>
  <Card title="scraper" icon="spider-web" href="/conductor/agents/scraper">
    Web scraping with retries
  </Card>
  <Card title="validator" icon="check-circle" href="/conductor/agents/validator">
    Data validation
  </Card>
  <Card title="rag" icon="database" href="/conductor/agents/rag">
    Vector search + LLM
  </Card>
  <Card title="hitl" icon="user-check" href="/conductor/agents/hitl">
    Human approval flow
  </Card>
  <Card title="fetcher" icon="download" href="/conductor/agents/fetcher">
    HTTP requests with caching
  </Card>
  <Card title="transformer" icon="wand-magic-sparkles" href="/conductor/agents/transformer">
    Data transformation
  </Card>
  <Card title="scheduler" icon="clock" href="/conductor/agents/scheduler">
    Cron-based execution
  </Card>
</CardGroup>

## Quick Start

Use pre-built agents like any other agent:

```yaml
ensemble: analyze-content

agents:
  - name: fetch-page
    agent: scraper
    inputs:
      url: ${input.url}

  - name: validate-data
    agent: validator
    inputs:
      data: ${fetch-page.output}
      schema: ${component.schema@v1.0.0}

  - name: analyze
    operation: think
    config:
      prompt: Analyze: ${validate-data.output}
```

### Using Debug Agents

Debug agents help you test and troubleshoot workflows during development:

```yaml
ensemble: debug-workflow

flow:
  # Echo agent: Inspect data at any point
  - name: inspect-input
    agent: echo
    input:
      data: ${input}

  # Delay agent: Simulate slow operations
  - name: simulate-delay
    agent: delay
    input:
      milliseconds: 2000

  # Inspect-context agent: View execution context
  - name: check-context
    agent: inspect-context
    input:
      includeEnv: false
      includeConfig: true
```

## Why Pre-built Agents?

**1. Proven Patterns**
Battle-tested implementations of common workflows. Not toy examples.

**2. Zero Setup**
No configuration needed. Sensible defaults. Override what you need.

**3. Maintained**
We handle edge cases, retries, errors. You focus on your logic.

**4. Versionable**
Reference specific versions with Edgit:
```yaml
agents:
  - name: scrape
    agent: scraper@v2.1.0
```

## Customization

Every pre-built agent supports:

- **Custom config**: Override defaults
- **Caching**: Add your own cache strategy
- **Retries**: Configure retry behavior
- **Conditions**: Conditional execution
- **State**: Manage persistent state

<Tabs>
  <Tab title="YAML">
```yaml
agents:
  - name: fetch
    agent: scraper
    inputs:
      url: ${input.url}
    cache:
      ttl: 3600
      key: scrape-${input.url}
    retry:
      maxAttempts: 5
      backoff: exponential
```
  </Tab>
  <Tab title="TypeScript">
```typescript
import { createEnsemble, step } from '@anthropic/conductor'

createEnsemble('custom-scrape')
  .addStep(
    step('fetch')
      .agent('scraper')
      .input({ url: '${input.url}' })
      .cache({ ttl: 3600, key: 'scrape-${input.url}' })
      .retry({ maxAttempts: 5, backoff: 'exponential' })
  )
  .build()
```
  </Tab>
</Tabs>

## When to Use

**Use pre-built agents when:**
- The pattern is common (scraping, validation, RAG)
- You want production quality without maintenance
- You need a starting point for customization

**Build custom agents when:**
- Your logic is domain-specific
- You need fine-grained control
- The pattern doesn't match any pre-built agent

## Composition

Pre-built agents compose naturally:

<Tabs>
  <Tab title="YAML">
```yaml
ensemble: content-pipeline

agents:
  # Scrape with retries
  - name: scrape
    agent: scraper
    inputs:
      url: ${input.url}

  # Validate structure
  - name: validate
    agent: validator
    inputs:
      data: ${scrape.output}

  # Transform to target format
  - name: transform
    agent: transformer
    inputs:
      data: ${validate.output}
      template: ${component.template@v1.0.0}

  # Store in vector DB
  - name: embed
    agent: rag
    config:
      action: embed
      text: ${transform.output}
```
  </Tab>
  <Tab title="TypeScript">
```typescript
import { createEnsemble, step } from '@anthropic/conductor'

const contentPipeline = createEnsemble('content-pipeline')
  // Scrape with retries
  .addStep(
    step('scrape')
      .agent('scraper')
      .input({ url: '${input.url}' })
  )
  // Validate structure
  .addStep(
    step('validate')
      .agent('validator')
      .input({ data: '${scrape.output}' })
  )
  // Transform to target format
  .addStep(
    step('transform')
      .agent('transformer')
      .input({
        data: '${validate.output}',
        template: '${component.template@v1.0.0}'
      })
  )
  // Store in vector DB
  .addStep(
    step('embed')
      .agent('rag')
      .config({ action: 'embed', text: '${transform.output}' })
  )
  .build()

export default contentPipeline
```
  </Tab>
</Tabs>

## Versioning Strategy

Pre-built agents follow semantic versioning:

- **v1.0.0**: Initial release
- **v1.1.0**: New features (backward compatible)
- **v1.1.1**: Bug fixes
- **v2.0.0**: Breaking changes

Pin versions for stability:
```yaml
agents:
  - name: scrape
    agent: scraper@v1.2.3  # Exact version
```

Or use ranges for auto-updates:
```yaml
agents:
  - name: scrape
    agent: scraper@v1.x.x  # Latest v1
```

## Next Steps

<CardGroup cols={2}>
  <Card title="scraper" icon="spider-web" href="/conductor/agents/scraper">
    Web scraping
  </Card>
  <Card title="validator" icon="check-circle" href="/conductor/agents/validator">
    Data validation
  </Card>
  <Card title="rag" icon="database" href="/conductor/agents/rag">
    Vector search
  </Card>
  <Card title="hitl" icon="user-check" href="/conductor/agents/hitl">
    Human approval
  </Card>
</CardGroup>
