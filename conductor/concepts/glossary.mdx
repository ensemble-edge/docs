---
title: "Glossary"
description: "Key terms and concepts in the Ensemble Edge ecosystem"
---

## Overview

This glossary explains the terminology used throughout Ensemble Edge, with a focus on clarifying terms that may have different meanings across Edgit and Conductor.

<Info>
  **Musical Metaphor:** Conductor uses musical terminology intentionally to distinguish itself from traditional workflow and agent frameworks. This helps users understand the orchestration model intuitively.
</Info>

## Core Terminology

### Ensemble

**In Conductor:** A workflow definition written in YAML that orchestrates multiple members to accomplish a task. Ensembles are the "sheet music" that define what happens, when, and in what order.

**Alternative Terms:** Workflow, pipeline, orchestration

**Example:**
```yaml
name: company-intelligence
description: Gather and analyze company data

flow:
  - member: fetch-data
  - member: analyze-data
  - member: generate-report
```

**Why "Ensemble"?**
- Reinforces the musical metaphor (members = musicians, ensembles = sheet music)
- Distinguishes from traditional workflow engines and DAG builders
- Emphasizes the composable, harmonic nature of coordinating multiple members

Throughout Conductor documentation, "ensemble" and "workflow" are used interchangeably—they mean the same thing.

---

### Member

**In Conductor:** An individual executable unit that performs a specific task within an ensemble. Members are the "musicians" in the orchestra—each plays one instrument well.

**Types of Members:**
- **Think Members** - AI reasoning with LLMs (GPT-4, Claude, Workers AI)
- **Function Members** - JavaScript/TypeScript business logic
- **Data Members** - Storage operations (KV, D1, R2, Vectorize)
- **API Members** - HTTP requests to external services

**Alternative Terms:** Agent, component (at runtime), task, step

**Why "Member"?**
- Reinforces the musical metaphor (members are musicians in the orchestra)
- Distinguishes from traditional autonomous AI agents
- Emphasizes single-responsibility principle (each member has one clear role)
- Creates consistency with "ensemble" terminology

Throughout Conductor documentation, "member" and "agent" are used interchangeably—they mean the same thing.

---

### Component

**In Edgit:** A versioned artifact stored in Git that can be independently versioned and deployed. Components are the source code or configuration files that become members at runtime.

**Examples:**
- Prompts (`.md` files)
- Agents (`.yaml` + `.ts` files)
- SQL queries (`.sql` files)
- Configuration files (`.json`, `.yaml`)

**Key Distinction:** Components are versioned artifacts in Git (Edgit), while members are runtime executors (Conductor). A component becomes a member when loaded into Conductor.

```yaml
# Component in Git (Edgit)
components/extraction-prompt.md

# Tagged version
extraction-prompt@v1.0.0

# Loaded as member in ensemble (Conductor)
members:
  - type: Think
    component: extraction-prompt@v1.0.0
```

---

### State

**In Conductor:** Shared context that flows through an ensemble execution, allowing members to read and write data without prop drilling.

**Key Features:**
- **Immutable snapshots** - Each member sees a consistent view
- **Access tracking** - Conductor knows which members use which state keys
- **Selective access** - Members only see declared state keys
- **Type-safe** - Validated via JSON schema

**Example:**
```yaml
state:
  schema:
    companyData: object
    analysis: object

flow:
  - member: fetch-data
    state:
      set: [companyData]  # Writes to state

  - member: analyze
    state:
      use: [companyData]  # Reads from state
      set: [analysis]     # Writes analysis
```

---

## Edgit Terminology

### Tag

An immutable version marker for a component at a specific Git commit. Tags never change once created.

**Format:** `component-name@version` (e.g., `extraction-prompt@v1.0.0`)

**Example:**
```bash
edgit tag create extraction-prompt v1.0.0
```

---

### Deployment

A mutable environment pointer that references a specific component version. Deployments can be updated to point to different versions.

**Example:**
```bash
# Initial deployment
edgit deploy set extraction-prompt v1.0.0 --to prod

# Update deployment
edgit deploy set extraction-prompt v2.0.0 --to prod
```

---

### Version

A semantic version number following [SemVer](https://semver.org/) (MAJOR.MINOR.PATCH).

**Examples:** `v1.0.0`, `v2.1.3`, `v0.5.0-beta.1`

---

## Conductor Terminology

### Executor

The runtime engine that executes ensembles by running members in sequence or parallel according to the flow definition.

**Key Responsibilities:**
- Parse ensemble YAML
- Resolve member dependencies
- Execute members in correct order
- Manage state
- Handle errors and retries

---

### Flow

The execution sequence defined in an ensemble. Flows can include sequential steps, parallel execution, conditional branching, loops, and error handling.

**Patterns:**
```yaml
# Sequential
flow:
  - member: step-1
  - member: step-2

# Parallel
flow:
  - parallel:
      - member: fetch-a
      - member: fetch-b

# Conditional
flow:
  - branch:
      if: ${check.output.score} > 0.8
      then:
        - member: approve
      else:
        - member: review
```

---

### Input

Data passed into an ensemble or member execution.

**Ensemble Input:**
```typescript
await executor.executeEnsemble(ensemble, {
  domain: 'acme.com',
  detailed: true
});
```

**Member Input:**
```yaml
- member: analyze
  input:
    domain: ${input.domain}
    detailed: ${input.detailed}
```

---

### Output

Data returned from a member or ensemble execution.

**Member Output:**
```yaml
output:
  report: ${generate-report.output.report}
  score: ${analyze.output.score}
```

---

### Cache

A mechanism to store and reuse member outputs to reduce costs and latency.

**Example:**
```yaml
- member: expensive-operation
  cache:
    ttl: 3600  # 1 hour
    key: ${input.id}
```

---

### Scoring

A quality evaluation system that validates member outputs and triggers retries if quality thresholds aren't met.

**Example:**
```yaml
scoring:
  enabled: true
  defaultThresholds:
    minimum: 0.7
    target: 0.8

flow:
  - member: generate-content
    scoring:
      evaluator: validate
      thresholds:
        minimum: 0.8
      criteria:
        accuracy: "Content must be factually accurate"
      onFailure: retry
```

---

## Platform Terminology

### Cloudflare Workers

A serverless execution environment that runs code at the edge in 300+ cities worldwide. Conductor is built to deploy on Cloudflare Workers.

**Key Benefits:**
- Zero infrastructure management
- Global distribution
- Sub-50ms cold starts
- Integrated platform (Workers AI, KV, D1, R2, Vectorize)

---

### Durable Objects

Cloudflare's stateful coordination primitive used by Conductor for:
- **ExecutionState** - Long-running workflow execution
- **HITLState** - Human-in-the-loop workflow suspension

---

### KV (Workers KV)

Cloudflare's global key-value store used for:
- Member output caching
- Deployment configuration
- Component version metadata

---

### D1

Cloudflare's serverless SQL database used for:
- Structured data storage
- Query operations in Data members

---

### R2

Cloudflare's object storage (S3-compatible) used for:
- Large file storage
- Document storage
- Artifact management

---

### Vectorize

Cloudflare's vector database used for:
- Semantic search
- RAG (Retrieval-Augmented Generation)
- Embedding storage

---

### AI Gateway

Cloudflare's LLM proxy with persistent caching and cost optimization features.

**Benefits:**
- Persistent caching across deployments
- Cost tracking and limits
- Rate limiting
- Request logging

---

## Integration Terminology

### Component → Member → Ensemble

The transformation flow from versioned artifact to execution:

1. **Component** (Edgit) - Versioned artifact in Git
2. **Member** (Conductor) - Runtime executor loaded from component
3. **Ensemble** (Conductor) - Workflow orchestrating multiple members

**Example:**
```yaml
# 1. Component in Git (Edgit)
components/analyzer.yaml
components/analyzer.ts

# 2. Tagged version (Edgit)
edgit tag create analyzer v1.0.0

# 3. Loaded as member (Conductor)
members/analyzer.yaml:
  name: analyzer
  type: Function
  component: analyzer@v1.0.0

# 4. Used in ensemble (Conductor)
ensembles/intelligence.yaml:
  flow:
    - member: analyzer
```

---

## Execution Terminology

### Execution Context

The runtime environment available to members during execution, including:
- Cloudflare Workers `env` bindings (KV, D1, R2, AI, etc.)
- Cloudflare Workers `ctx` (execution context)
- Ensemble input
- State snapshot
- Previous member outputs

---

### Interpolation

Template variable substitution in ensemble YAML using `${...}` syntax.

**Sources:**
- `${input.field}` - Input data
- `${state.key}` - Shared state
- `${member-name.output.field}` - Member outputs
- `${env.VARIABLE}` - Environment variables

**Example:**
```yaml
- member: process
  input:
    domain: ${input.domain}
    cached: ${state.companyData}
    result: ${fetch-data.output.result}
    apiKey: ${env.API_KEY}
```

---

## Best Practices Terminology

### Prop Drilling

**Anti-pattern:** Passing data through multiple intermediate members that don't need it.

**Solution:** Use shared state instead.

```yaml
# ❌ Bad - Prop drilling
- member: fetch
- member: transform
  input:
    data: ${fetch.output.data}
- member: analyze
  input:
    data: ${transform.output.data}

# ✅ Good - Shared state
state:
  schema:
    data: object

flow:
  - member: fetch
    state:
      set: [data]
  - member: transform
    state:
      use: [data]
  - member: analyze
    state:
      use: [data]
```

---

### Single Responsibility

**Principle:** Each member should do one thing well.

**Example:**
```yaml
# ✅ Good - Focused members
- member: fetch-data
- member: validate-data
- member: analyze-data
- member: generate-report

# ❌ Bad - Monolithic member
- member: do-everything
```

---

## Version Control Terminology

### Independent Versioning

**Principle:** Each component versions independently, allowing optimal version combinations.

**Example:**
```bash
# Ancient prompt (perfect), latest agent (cutting edge)
extraction-prompt@v0.1.0
company-analyzer@v3.0.0
validation-sql@v2.5.0
```

**Benefit:** No need to bump entire codebase version when changing one component.

---

### Atomic Deployment

**Principle:** Deploy all components atomically to ensure consistency.

**Example:**
```bash
# Deploy multiple component versions together
edgit deploy set extraction-prompt v1.0.0 --to prod
edgit deploy set company-analyzer v2.0.0 --to prod
edgit deploy set validation-sql v1.5.0 --to prod
```

---

## Related Documentation

<CardGroup cols={2}>
  <Card
    title="Ensembles"
    icon="sheet-plastic"
    href="/conductor/concepts/ensembles"
  >
    Learn about workflow orchestration
  </Card>

  <Card
    title="Members"
    icon="users"
    href="/conductor/concepts/members"
  >
    Understand executable units
  </Card>

  <Card
    title="Edgit Overview"
    icon="cube"
    href="/edgit/overview"
  >
    Component versioning system
  </Card>

  <Card
    title="Conductor Overview"
    icon="network-wired"
    href="/conductor/overview"
  >
    Edge orchestration framework
  </Card>
</CardGroup>
