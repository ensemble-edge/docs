---
title: "Deployment Guide"
description: "Deploy Conductor to Cloudflare Workers"
---

## Overview

Deploy your Conductor project to Cloudflare's global edge network in minutes. This guide covers local development, production deployment, environment configuration, and monitoring.

## Prerequisites

- Node.js 18+ installed
- Cloudflare account (free tier works)
- Wrangler CLI installed

```bash
npm install -g wrangler
```

## Local Development

### Start Development Server

```bash
# Start Wrangler dev server
npm run dev

# Or with custom port
npx wrangler dev --port 8788
```

Access at `http://localhost:8787`

### Test Locally

```bash
# Execute ensemble
curl -X POST http://localhost:8787/api/v1/execute \
  -H "Content-Type: application/json" \
  -d '{
    "ensemble": "hello-world",
    "input": {
      "name": "World"
    }
  }'
```

### Local Environment Variables

Create `.dev.vars` for local secrets:

```bash
# .dev.vars (DO NOT COMMIT)
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...
GROQ_API_KEY=gsk_...
```

Add to `.gitignore`:

```
.dev.vars
```

## Production Deployment

### 1. Login to Cloudflare

```bash
npx wrangler login
```

### 2. Configure wrangler.toml

```toml
name = "my-conductor-project"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[ai.gateway]
id = "my-gateway"
cache_ttl = 3600

[[kv_namespaces]]
binding = "CACHE"
id = "your-kv-namespace-id"

[[d1_databases]]
binding = "DB"
database_name = "my-database"
database_id = "your-database-id"

[[r2_buckets]]
binding = "STORAGE"
bucket_name = "my-bucket"

[ai]
binding = "AI"
```

### 3. Create Resources

```bash
# Create KV namespace
npx wrangler kv:namespace create CACHE

# Create D1 database
npx wrangler d1 create my-database

# Create R2 bucket
npx wrangler r2 bucket create my-bucket
```

### 4. Set Secrets

```bash
# Set production secrets
npx wrangler secret put OPENAI_API_KEY
npx wrangler secret put ANTHROPIC_API_KEY
npx wrangler secret put GROQ_API_KEY
```

### 5. Deploy

```bash
# Deploy to production
npm run deploy

# Or deploy with wrangler directly
npx wrangler deploy
```

Your Worker is now live at:
```
https://my-conductor-project.your-subdomain.workers.dev
```

## Environment Configuration

### Multiple Environments

Use different wrangler files:

```toml
# wrangler.dev.toml
name = "my-project-dev"

[[kv_namespaces]]
binding = "CACHE"
id = "dev-kv-id"
```

```toml
# wrangler.prod.toml
name = "my-project-prod"

[[kv_namespaces]]
binding = "CACHE"
id = "prod-kv-id"
```

Deploy to specific environment:

```bash
# Development
npx wrangler deploy --config wrangler.dev.toml

# Production
npx wrangler deploy --config wrangler.prod.toml
```

### Environment Variables

```toml
[vars]
ENVIRONMENT = "production"
API_VERSION = "v1"
LOG_LEVEL = "info"
```

Access in code:

```typescript
console.log('Environment:', env.ENVIRONMENT);
```

## Custom Domains

### 1. Add Domain in Dashboard

1. Go to Workers & Pages
2. Select your Worker
3. Click "Triggers" tab
4. Click "Add Custom Domain"
5. Enter your domain (e.g., `api.example.com`)

### 2. Update DNS

Cloudflare automatically configures DNS for domains managed by Cloudflare.

For external domains, add CNAME:
```
api.example.com CNAME my-project.your-subdomain.workers.dev
```

### 3. Test

```bash
curl https://api.example.com/health
```

## CI/CD Integration

### GitHub Actions

```yaml
# .github/workflows/deploy.yml
name: Deploy to Cloudflare Workers

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Deploy to Cloudflare Workers
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
```

### GitLab CI

```yaml
# .gitlab-ci.yml
deploy:
  image: node:20
  script:
    - npm ci
    - npm test
    - npx wrangler deploy
  only:
    - main
  variables:
    CLOUDFLARE_API_TOKEN: $CLOUDFLARE_API_TOKEN
```

## Monitoring

### View Logs

```bash
# Tail logs in real-time
npx wrangler tail

# Filter logs
npx wrangler tail --search "error"
```

### Analytics

View in Cloudflare dashboard:
1. Workers & Pages
2. Select your Worker
3. Click "Metrics" tab

Metrics available:
- Requests per second
- Success rate
- CPU time
- Duration
- Errors

### Custom Logging

```typescript
// Structured logging
console.log(JSON.stringify({
  level: 'info',
  message: 'Ensemble executed',
  ensemble: 'company-intelligence',
  duration: result.executionTime,
  success: result.success
}));
```

### Error Tracking

```typescript
// Log errors with context
console.error(JSON.stringify({
  level: 'error',
  message: error.message,
  stack: error.stack,
  ensemble: ensembleName,
  input: sanitizeInput(input),
  timestamp: Date.now()
}));
```

## Performance Optimization

### Enable Caching

```yaml
# Member-level caching
- member: expensive-operation
  cache:
    ttl: 3600
```

### Use AI Gateway

```yaml
config:
  routing: cloudflare-gateway  # Persistent caching
```

### Optimize Bundle Size

```typescript
// Lazy load built-in members
import { getBuiltInRegistry } from '@ensemble-edge/conductor';
const member = getBuiltInRegistry().create('scrape', config, env);
```

### Monitor Performance

```typescript
const startTime = performance.now();
const result = await executor.executeEnsemble(ensemble, input);
const duration = performance.now() - startTime;

console.log('Performance:', {
  ensemble: ensemble.name,
  duration,
  cacheHits: result.metadata?.cacheHits,
  memberCount: result.metadata?.memberCount
});
```

## Scaling

### Automatic Scaling

Cloudflare Workers scale automatically:
- No configuration needed
- Handle millions of requests
- Pay only for what you use

### Rate Limiting

```typescript
// Implement rate limiting
const rateLimiter = new Map<string, number>();

export default {
  async fetch(request, env, ctx) {
    const clientId = request.headers.get('x-client-id');

    // Check rate limit
    const requestCount = rateLimiter.get(clientId) || 0;
    if (requestCount > 100) {
      return new Response('Rate limit exceeded', { status: 429 });
    }

    rateLimiter.set(clientId, requestCount + 1);

    // Process request
    return handleRequest(request, env, ctx);
  }
};
```

## Troubleshooting

### Check Deployment Status

```bash
npx wrangler deployments list
```

### View Worker Details

```bash
npx wrangler whoami
npx wrangler list
```

### Test Production Endpoint

```bash
curl https://your-worker.workers.dev/health
```

### Common Issues

#### "Module not found"

**Solution:** Build the project first
```bash
npm run build
npx wrangler deploy
```

#### "Binding not found"

**Solution:** Create and configure binding in wrangler.toml
```bash
npx wrangler kv:namespace create CACHE
# Add ID to wrangler.toml
```

#### "Secret not set"

**Solution:** Set the secret
```bash
npx wrangler secret put API_KEY
```

## Best Practices

1. **Use secrets for sensitive data** - Never commit API keys
2. **Test locally first** - Use `npm run dev` before deploying
3. **Enable caching** - Reduce costs and improve performance
4. **Monitor logs** - Watch for errors and performance issues
5. **Use custom domains** - Professional URLs for production
6. **Set up CI/CD** - Automate deployments
7. **Tag deployments** - Use git tags for releases
8. **Test in staging** - Deploy to dev environment first

## Related Documentation

<CardGroup cols={2}>
  <Card
    title="Configuration Guide"
    icon="gear"
    href="/conductor/deployment/configuration"
  >
    Complete wrangler.toml setup
  </Card>

  <Card
    title="Environment Variables"
    icon="key"
    href="/conductor/deployment/environment-variables"
  >
    Manage secrets and vars
  </Card>

  <Card
    title="Bindings"
    icon="link"
    href="/conductor/deployment/bindings"
  >
    Configure KV, D1, R2, Vectorize
  </Card>

  <Card
    title="Testing"
    icon="flask"
    href="/conductor/deployment/testing"
  >
    Test before deploying
  </Card>
</CardGroup>
